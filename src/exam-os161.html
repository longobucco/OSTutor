<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>Esercizi OS161</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
        background-color: #f9f9f9;
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 2rem;
      }
      #esercizi-list {
        max-width: 800px;
        margin: 0 auto;
      }
      .esercizio-card {
        background: #fff;
        border-left: 5px solid #3498db;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
        padding: 0;
        border-radius: 6px;
        overflow: hidden;
      }
      .esercizio-header {
        cursor: pointer;
        padding: 1rem;
        font-weight: bold;
        background: #eaf6fb;
        display: flex;
        justify-content: space-between;
        align-items: center;
        outline: none;
      }
      .esercizio-header:focus {
        box-shadow: 0 0 0 2px #3498db;
      }
      .arrow {
        font-size: 1.2em;
        transition: transform 0.2s;
      }
      .esercizio-content {
        padding: 1rem;
        border-top: 1px solid #eee;
        display: none;
      }
      .domanda {
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .risposta {
        color: #27ae60;
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .spiegazione {
        margin-top: 0.5rem;
      }
    </style>
  </head>
  <body>
    <h1>Esercizi OS161</h1>
    <label for="esame-select" style="font-weight: bold; margin-right: 1rem"
      >Scegli scheda:</label
    >
    <select id="esame-select" style="margin-bottom: 2rem">
      <option value="settembre2024">Settembre 2024</option>
      <option value="gennaio2025">Gennaio 2025</option>
      <option value="giugno2024">Giugno 2024</option>
      <option value="luglio2016">Luglio 2016</option>
      <option value="lab2">Laboratorio #2</option>
    </select>
    <span
      id="completato-label"
      style="margin-left: 1em; font-weight: bold; color: #27ae60; display: none"
      >Completato</span
    >
    <div id="esercizi-list"></div>
    <button
      id="completato-btn"
      style="
        margin-top: 2rem;
        padding: 0.7rem 1.5rem;
        background: #27ae60;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 1.1em;
        cursor: pointer;
      "
    >
      Completato
    </button>
    <noscript>
      <p>
        Abilita JavaScript per visualizzare gli esercizi in modo interattivo.
      </p>
    </noscript>
    <script>
      // Funzione per salvare il completamento dell'esame/lab su backend Python
      function salvaCompletamento(nome) {
        fetch("http://localhost:8080/completato", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nome }),
        })
          .then((res) => {
            if (res.ok) {
              aggiornaCompletatoLabel();
            } else {
              res.text().then((t) => alert("Errore: " + t));
            }
          })
          .catch(() =>
            alert("Errore di connessione col server completamento.")
          );
      }

      // Funzione per rimuovere il completamento
      function rimuoviCompletamento(nome) {
        fetch("http://localhost:8080/rimuovi_completato", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nome }),
        })
          .then((res) => {
            if (res.ok) {
              aggiornaCompletatoLabel();
            } else {
              res.text().then((t) => alert("Errore: " + t));
            }
          })
          .catch(() =>
            alert("Errore di connessione col server completamento.")
          );
      }

      // Mostra o nasconde la scritta "Completato" accanto al select
      function aggiornaCompletatoLabel() {
        fetch("http://localhost:8080/completed.json")
          .then((res) => res.json())
          .then((data) => {
            const completati = data.completati || [];
            const select = document.getElementById("esame-select");
            const label = document.getElementById("completato-label");
            const btn = document.getElementById("completato-btn");
            const nome = select.options[select.selectedIndex].text;
            if (completati.includes(nome)) {
              label.style.display = "";
              btn.textContent = "Non completato";
              btn.style.background = "#e74c3c";
              btn.onclick = function () {
                rimuoviCompletamento(nome);
              };
            } else {
              label.style.display = "none";
              btn.textContent = "Completato";
              btn.style.background = "#27ae60";
              btn.onclick = function () {
                salvaCompletamento(nome);
              };
            }
          })
          .catch(() => {
            document.getElementById("completato-label").style.display = "none";
          });
      }
      // Laboratorio #2
      const eserciziLab2 = [
        {
          riassunto: {
            gestione_memoria: {
              traduzione_e_tlb: {
                spazio_indirizzi:
                  "4GB totali, 2GB kernel (alto) + 2GB utente (basso)",
                zone_kernel: [
                  "Primo 0.5GB: no TLB, cached, relocation semplice",
                  "Secondo 0.5GB: no TLB, uncached (I/O mappato in memoria)",
                  "Ultimo 1GB: mappato in TLB (OS/161 non lo usa)",
                ],
                tlb: "64 voci, page number, frame number, ASID, flag valid/dirty",
              },
              dumbvm_addrspace: {
                descrizione: "Gestisce traduzione su page fault",
                segmenti: [".text", ".rodata", ".data", ".bss", ".sbss"],
                stack: "12 pagine create a 0x7fffffff",
              },
              allocazione_memoria: {
                funzioni: [
                  "ram_bootstrap(): trova ultimo indirizzo fisico",
                  "ram_stealmem(npages): alloca pagine contigue, aggiorna firstpaddr",
                  "getppages(): wrapper con spinlock; prova getfreeppages(), poi ram_stealmem()",
                ],
              },
              rilascio_memoria: {
                note: "OS/161 base non libera memoria; aggiunto freeppages() con bitmap",
                bitmap: {
                  freeRamFrames: "1=libero, 0=occupato",
                  allocSize: "numero di pagine allocate per blocco",
                },
                funzioni: [
                  "free_kpages(): libera memoria kernel",
                  "as_destroy(): libera spazio utente (codice, dati, stack)",
                  "freeppages(): aggiorna bitmap e allocSize",
                ],
              },
            },
            system_call: {
              meccanismo: {
                trap: "passaggio user mode → kernel mode",
                trapframe: "salva registri, PC, SP",
                syscall_dispatch:
                  "switch su tf_v0, parametri in tf_a0-tf_a2, risultato in tf_v0, errore in tf_a3, avanzamento tf_epc",
              },
              syscall_implementate: [
                "sys_write(fd, buf_ptr, size): stdout/stderr via putch()",
                "sys_read(fd, buf_ptr, size): stdin via getch()",
                "sys__exit(status): distrugge address space, chiude thread",
              ],
            },
            funzioni_chiave: [
              "ram_stealmem(npages)",
              "getppages(npages)",
              "getfreeppages(npages)",
              "free_kpages(vaddr)",
              "as_destroy(addrspace)",
              "freeppages(paddr, npages)",
            ],
            sincronizzazione: ["Spinlock: freemem_lock, stealmem_lock"],
            strutture_dati: [
              "freeRamFrames[]",
              "allocSize[]",
              "nRamFrames",
              "allocTableActive",
            ],
          },
        },
        {
          codice: `int sys_write(int fd, userptr_t buf_ptr, size_t size) {\n int i;\n char *p = (char *)buf_ptr;\n if (fd!=STDOUT_FILENO && fd!=STDERR_FILENO)\n return file_write(fd, buf_ptr, size);\n for (i=0; i<(int)size; i++)\n putch(p[i]);\n return (int)size;\n}`,
          domande: [
            {
              domanda:
                'Sostituire il ciclo con: for (i=0; i<(int)size; i++) kprintf("%c", p[i]);',
              risposta: "Sì",
              soluzione:
                'Con stdout/stderr mappati sulla console, kprintf("%c", ...) invia caratteri alla stessa destinazione di putch; è funzionalmente equivalente al loop originale.',
            },
            {
              domanda: 'Sostituire il ciclo con: kprintf("%s", p);',
              risposta: "Sì",
              soluzione:
                "Il formato \"%s\" accetta un char* e stampa i byte fino a '\\0'. Con buffer terminato da null e console come sink, è compatibile. (Attenzione: se p non è null-terminated, non è sicuro.)",
            },
            {
              domanda: 'Sostituire il ciclo con: kprintf("%s", &p);',
              risposta: "No",
              soluzione:
                'Qui &p è di tipo char** (indirizzo del puntatore), non un char*. "%s" richiede un char*; passare un char** è tipo errato e produce comportamento indefinito.',
            },
            {
              domanda: "Sostituire il ciclo con: file_write(fd, p, size);",
              risposta: "No",
              soluzione:
                "Per traccia, stdin/stdout/stderr sono fissi sulla console e non reindirizzabili a file; invocare file_write per stdout/stderr non rispetta il modello imposto.",
            },
            {
              domanda:
                "Si supponga un sistema OS/161. Descrivere la struttura trapframe e il suo utilizzo durante le chiamate di sistema. In particolare, indicare la funzione del registro v0 dell'architettura MIPS.",
              risposta:
                "La trapframe salva lo stato del programma tramite i registri MIPS quando viene eseguita una chiamata di sistema.",
              soluzione:
                "In OS/161, la trapframe memorizza i registri del processore MIPS al momento dell'eccezione o chiamata di sistema, permettendo al kernel di ripristinare l'esecuzione utente. Nei registri a0, a1, a2 sono presenti i primi tre parametri della system call, in a3 un flag di successo/errore, e in v0 il codice identificativo della system call invocata. Dopo l'esecuzione, v0 viene aggiornato con il valore di ritorno della chiamata.",
            },
            {
              domanda:
                "Si supponga un sistema OS/161. È necessario l'utilizzo di una chiamata di sistema per la scrittura su stdin (es. sys_write) per un processo utente? È possibile utilizzare kprintf() invece? Motivare le risposte.",
              risposta:
                "Sì, per un processo utente è necessaria una system call; kprintf() è utilizzabile solo nel kernel.",
              soluzione:
                "Le chiamate di sistema consentono a un processo in user space di accedere a funzionalità del kernel. Per scrivere su dispositivi come stdin/stdout da un processo utente è necessario usare una system call come sys_write. La funzione kprintf(), invece, è parte del kernel e non può essere richiamata direttamente dall'user space, quindi non è alternativa per processi utente.",
            },
          ],
        },
      ];

      const eserciziLuglio2016 = [
        {
          domanda: "Che cosa è il trapframe? Quali dati vi vengono memorizzati?",
          risposta:
            "È una struttura che memorizza lo stato del processo durante un cambio di contesto.",
          spiegazione:
            "Il trapframe contiene i registri e altre informazioni di stato necessarie per ripristinare l'esecuzione del processo dopo un'eccezione o system call. Ad esempio, durante una syscall salva i valori dei registri MIPS del processo utente.",
        },
        {
          domanda:
            "Sia dato un puntatore a trapframe tf, che cosa sono i campi tf->tf_a0, tf->tf_a1, …?",
          risposta: "Parametri della system call, corrispondenti ai registri MIPS a0, a1, …",
          spiegazione:
            "Questi campi rappresentano gli argomenti passati alla system call. Ad esempio, in read/write possono contenere il file descriptor, il puntatore al buffer e la dimensione del trasferimento.",
        },
        {
          domanda:
            "Perché la printf in OS/161 non viene realizzata chiamando direttamente kprintf?",
          risposta: "Perché kprintf è una funzione del kernel e non è invocabile direttamente dall'user space.",
          spiegazione:
            "La printf di libreria C in OS/161 usa vprintf, che a sua volta chiama write per passare i dati al kernel. kprintf è accessibile solo dal codice kernel, quindi il codice utente deve passare tramite una system call.",
        },
        {
          domanda:
            "Perché, in OS/161, il menu non attende la fine del programma utente lanciato con p <file eseguibile>?",
          risposta:
            "Perché mancano la system call sys_exit e il meccanismo di attesa/sincronizzazione nel kernel.",
          spiegazione:
            "Attualmente, menu_execute avvia il programma ma il kernel non aspetta la sua terminazione. Servirebbe un'implementazione di sys_exit e un sistema di attesa basato su interrupt e sincronizzazione per bloccare il menu fino alla conclusione del processo.",
        },
      ];
      
      const esercizi = [
        {
          domanda:
            "Sebbene la soluzione proposta per supportare la deallocazione della memoria (freeppages) sia basata su una bitmap, potrebbe essere utilizzata anche una lista concatenata.",
          risposta: "TRUE",
          spiegazione:
            "Una lista concatenata è un'alternativa possibile alla bitmap per gestire i blocchi di memoria libera, anche se meno efficiente in termini di accesso e frammentazione. OS/161 usa una bitmap, ma una linked list sarebbe concettualmente valida.",
        },
        {
          domanda:
            "La funzione ram_stealmem alloca in modo incrementale la memoria a partire dal primo indirizzo disponibile dopo aver fatto load del kernel.",
          risposta: "TRUE",
          spiegazione:
            "ram_stealmem alloca memoria in modo grezzo e lineare, partendo dall’indirizzo subito dopo la fine del kernel, senza supportare la deallocazione. È usata solo all'inizio, prima dell'inizializzazione completa della gestione della memoria.",
        },
        {
          domanda:
            "Quando si utilizza una bitmap per tenere traccia della RAM allocata/libera, è necessario un secondo array che memorizzi le dimensioni delle partizioni allocate per l'allocazione sia della memoria dinamica del kernel che dei processi utente.",
          risposta: "FALSE",
          spiegazione:
            "Una bitmap tiene traccia dello stato di ciascun frame (libero/occupato), ma non richiede necessariamente un secondo array per le dimensioni delle allocazioni. Le dimensioni vengono gestite logicamente dal gestore della memoria, non servono strutture separate in questo caso.",
        },
        {
          domanda:
            "Lo stack di un processo utente non viene allocato (in dumbvm) chiamando ram_stealmem, perché la dimensione dello stack è una costante e lo stack si trova sempre agli stessi indirizzi logici.",
          risposta: "FALSE",
          spiegazione:
            "In dumbvm, lo stack viene comunque allocato in RAM con ram_stealmem, come ogni altra parte della memoria utente (stack, heap, text, data). Il fatto che abbia un indirizzo logico fisso non implica che non serva l’allocazione fisica.",
        },
        {
          domanda:
            "Lo schema di allocazione utilizzato da ram_stealmem non consentirà l'intercalare partizioni contigue del kernel e dei processi user (in altre parole, le partizioni del kernel e le partizioni user non saranno mai interlacciate).",
          risposta: "FALSE",
          spiegazione:
            "Poiché ram_stealmem alloca memoria in modo sequenziale prima che il sistema sia completamente operativo, non è garantita alcuna separazione o intercalazione strutturata tra memoria kernel e user. Anzi, possono trovarsi mescolate in memoria fisica.",
        },
        {
          domanda:
            "La funzione ram_stealmem viene chiamata per l'allocazione della memoria sia del kernel (memoria dinamica) che dei processi user.",
          risposta: "TRUE",
          spiegazione:
            "In OS/161, prima che sia inizializzato un sistema più avanzato di gestione della memoria (es. con freeppages o bitmap), sia la memoria dinamica del kernel che quella utente vengono allocate tramite ram_stealmem.",
        },
        {
          domanda: "Convertire l'indirizzo logico 0x8110 in indirizzo fisico",
          risposta: "0x201110",
          spiegazione:
            "L'indirizzo 0x8110 rientra nel primo segmento dello spazio utente, che inizia da as_vbase1 = 0x3000 e si estende per 3 pagine da 4 KB, quindi fino a 0xF000. Essendo 0x8110 compreso tra 0x3000 e 0xF000, si trova in questo intervallo. Il corrispondente indirizzo fisico si ottiene sommando all'indirizzo base fisico as_pbase1 = 0x200000 l'offset dell'indirizzo virtuale all'interno del segmento: 0x8110 - 0x3000 = 0x5110. Quindi l'indirizzo fisico è 0x200000 + 0x5110 = 0x201110.",
        },
        {
          domanda: "Convertire l'indirizzo logico 0x6500 in indirizzo fisico",
          risposta: "0x80006500 (fuori dallo user space)",
          spiegazione:
            "L'indirizzo 0x6500 non appartiene a nessuno dei due segmenti utente: non è compreso né tra 0x3000 e 0xF000 (primo segmento), né tra 0x7000 e 0x17000 (secondo segmento). In OS/161, se un indirizzo non rientra nello spazio utente e non appartiene a una regione valida, viene considerato appartenente al kernel. In dumbvm, gli indirizzi del kernel sono mappati 1:1, quindi 0x6500 è interpretato come fisico nel kernel space → 0x80006500.",
        },
        {
          domanda:
            "Convertire l'indirizzo logico 0x7FFFE010 in indirizzo fisico",
          risposta: "0x3FE010",
          spiegazione:
            "L'indirizzo 0x7FFFE010 si trova nello spazio di stack utente. In dumbvm, lo stack utente occupa le ultime 18 pagine da 4 KB prima dell'indirizzo USERSTACK = 0x80000000. Quindi lo stack inizia a 0x80000000 - 18×4096 = 0x7FFFC000. Poiché 0x7FFFE010 è compreso tra 0x7FFFC000 e 0x80000000, appartiene allo stack. Il base fisico dello stack è as_stackpbase = 0x400000, e l'offset è 0x7FFFE010 - 0x7FFFC000 = 0x2010. Sommando: 0x400000 + 0x2010 = 0x3FE010.",
        },
        {
          domanda:
            "Convertire l'indirizzo logico 0x805000B0 in indirizzo fisico",
          risposta: "0x5000B0",
          spiegazione:
            "L'indirizzo 0x805000B0 si trova nello spazio del kernel, poiché è maggiore di 0x80000000. In dumbvm, lo spazio del kernel è mappato 1:1, cioè l'indirizzo fisico corrisponde all'indirizzo logico meno 0x80000000. Calcolando: 0x805000B0 - 0x80000000 = 0x5000B0.",
        },
      ];
      const eserciziSettembre2024 = [
        ...esercizi.slice(0, 10),
        {
          domanda:
            "La funzione sys_getpid è necessaria per implementare sys_waitpid, perché serve il PID del processo in attesa?",
          risposta: "No",
          spiegazione:
            "sys_waitpid riceve già come parametro il PID del processo da attendere, quindi non ha bisogno di chiamare sys_getpid per ottenerlo.",
        },
        {
          domanda:
            "La funzione sys_getpid è necessaria per implementare la system call getpid ed è chiamata direttamente da un processo utente?",
          risposta: "No",
          spiegazione:
            "Il processo utente invoca getpid in userland, che genera una syscall; sys_getpid viene chiamata dal kernel, non direttamente dal processo utente.",
        },
        {
          domanda:
            "La funzione sys_getpid è necessaria per implementare la system call getpid ed è chiamata dal kernel nella funzione syscall?",
          risposta: "Sì",
          spiegazione:
            "Quando la syscall getpid viene intercettata, il kernel invoca sys_getpid per ottenere il PID del processo corrente.",
        },
        {
          domanda:
            "La funzione sys_getpid restituisce il PID del processo corrente?",
          risposta: "Sì",
          spiegazione:
            "sys_getpid restituisce sempre il PID del processo in esecuzione che l'ha invocata.",
        },
        {
          domanda:
            "La funzione sys_getpid è chiamata per ottenere il PID di un altro processo (quello da attendere)?",
          risposta: "No",
          spiegazione:
            "sys_getpid restituisce il PID del processo corrente, non di altri processi.",
        },
        {
          domanda:
            "La funzione sys_getpid è chiamata da sys__exit per sapere quale processo segnalare?",
          risposta: "No",
          spiegazione:
            "sys__exit non chiama sys_getpid; utilizza già le strutture del processo corrente per sapere il proprio PID.",
        },
        {
          domanda:
            "Perché è un errore chiamare cv_wait senza aver prima fatto lock_acquire?",
          risposta:
            "Perché il lock deve essere posseduto quando si chiama cv_wait.",
          spiegazione:
            "cv_wait rilascia e riacquisisce il lock internamente; se non lo possiedi all'inizio, l'uso è scorretto e può causare race condition.",
        },
        {
          domanda:
            "Perché è sbagliato fare un return condizionato prima di lock_release?",
          risposta:
            "Perché può causare deadlock e saltare operazioni di pulizia.",
          spiegazione:
            "Un return all'interno della sezione critica salta la proc_destroy e lascia il lock acquisito, bloccando eventuali altri thread che tentano di acquisirlo.",
        },
        {
          domanda:
            "Perché è un errore chiamare proc_destroy con curproc invece di proc?",
          risposta:
            "Perché si distruggerebbe il processo corrente invece di quello atteso.",
          spiegazione:
            "Il processo padre in attesa deve eliminare il processo figlio terminato (parametro proc), non se stesso, altrimenti verrebbe eliminato erroneamente.",
        },
      ];

      // --- INIZIO INSERIMENTO SEZIONE LUGLIO 2016 (a riga 461) ---
      const eserciziLuglio2016Section = [
        ...eserciziLuglio2016
      ];
      // --- FINE INSERIMENTO SEZIONE LUGLIO 2016 ---
      const eserciziGennaio2025 = [
        {
          domanda:
            "Le modifiche a conf.kern + esecuzione di ./config PROJECT sono sufficienti per compilare syscall/project.c con bmake depend + bmake?",
          risposta: "No",
          spiegazione:
            "Le modifiche definiscono l'opzione e il file opzionale, ma affinché il file venga effettivamente compilato, l'opzione deve essere abilitata esplicitamente nel file PROJECT con la direttiva 'options project'.",
        },
        {
          domanda:
            "Quale file viene generato da ./config PROJECT? È sempre generato o solo se 'options project' è presente in PROJECT?",
          risposta: "opt-project.h (sempre generato)",
          spiegazione:
            "Il file viene generato automaticamente se 'conf.kern' contiene 'defoption project', anche se 'options project' non è presente nel file PROJECT.",
        },
        {
          domanda: "Cosa contiene il file opt-project.h?",
          risposta: "#define OPT_PROJECT 1 oppure #define OPT_PROJECT 0",
          spiegazione:
            "Include anche la protezione contro inclusioni multiple. Il valore 1 o 0 dipende dalla presenza o assenza della riga 'options project' nel file PROJECT.",
        },
        {
          domanda:
            "Come si può compilare project_init() in main.c solo se l’opzione project è attiva?",
          risposta:
            '#include "opt-project.h" seguito da #if OPT_PROJECT project_init(); #endif',
          spiegazione:
            "La macro OPT_PROJECT, definita in opt-project.h, consente di includere codice solo quando l’opzione è abilitata.",
        },
        {
          domanda:
            "Quale, tra trapframe e switchframe, viene usato per gestire una system call?",
          risposta: "Trapframe",
          spiegazione:
            "Viene utilizzato un trapframe, perché una chiamata di sistema viene gestita tramite un protocollo trap/interrupt (una chiamata di sistema è una sorta di interruzione software).",
        },
        {
          domanda:
            "Un trapframe viene allocato nello user stack o nello stack a livello kernel di un processo?",
          risposta: "Stack a livello kernel",
          spiegazione:
            "Il trapframe viene allocato nello stack del kernel, poiché è una struttura dati del kernel. Lasciarlo nello user space lo renderebbe vulnerabile a modifiche da parte del programma utente.",
        },
        {
          domanda:
            "Perché i dispositivi di IO sono mappati in kseg1? È possibile che un dispositivo di IO sia mappato in kseg0?",
          risposta: "Sono mappati in kseg1; non è corretto mapparli in kseg0.",
          spiegazione:
            "I dispositivi IO sono mappati in kseg1 perché questa regione non è mappata in cache. Le operazioni su dispositivi devono essere dirette e non passare dalla cache. Kseg0, invece, è cache-mapped e quindi non adatto.",
        },
        {
          domanda:
            "Cosa succede se un processo user chiama read(fd, buf, nb), dove buf è un indirizzo in kseg0? Cosa dovrebbe fare la system call SYS_read, al fine di gestire correttamente questo caso?",
          risposta: "È un errore: SYS_read deve rifiutare la chiamata.",
          spiegazione:
            "L'indirizzo di destinazione appartiene al kernel e non dovrebbe essere accessibile da codice utente. SYS_read dovrebbe controllare la validità dell’indirizzo e rifiutare l’operazione per sicurezza, restituendo un errore.",
        },
      ];
      const eserciziGiugno2024 = [
        {
          domanda:
            "L'indirizzo 0x80803005 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico kernel",
          spiegazione:
            "Non può essere un indirizzo logico utente perché è > 2GB. Non può essere un indirizzo fisico perché è maggiore di 4MB (la RAM disponibile). Può essere un indirizzo logico del kernel, ma nel contesto specifico non è compatibile con la RAM disponibile, che termina a 0x80400000.",
        },
        {
          domanda:
            "L'indirizzo 0x312010 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico utente o indirizzo fisico",
          spiegazione:
            "L'indirizzo è < 2GB, quindi valido come indirizzo logico utente. È anche < 4MB, quindi può essere un indirizzo fisico valido. Non può essere un indirizzo logico del kernel perché è al di sotto del limite minimo del kernel (0x80000000).",
        },
        {
          domanda:
            "L'indirizzo 0x532100 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico utente",
          spiegazione:
            "È < 2GB, quindi può essere un indirizzo logico utente. Tuttavia è > 4MB, quindi non può essere un indirizzo fisico (dato che la RAM ha solo 4MB). Non è un indirizzo logico del kernel, poiché è < 0x80000000.",
        },
        {
          domanda:
            "Dato l'indirizzo logico utente 0x4010, calcolare l'indirizzo fisico corrispondente usando: as_pbase1 = 0x100000, as_pbase2 = 0x200000, as_vbase1 = 0x3000, as_vbase2 = 0x6000, as_npages1 = 2, as_npages2 = 4",
          risposta: "0x10001010",
          spiegazione:
            "Le pagine in OS/161 sono da 4KB (12 bit di offset). L'indirizzo 0x4010 appartiene alla pagina 4 ed ha un offset di 0x10. Il primo segmento utente parte da 0x3000 e ha 2 pagine (fino a 0x7000), quindi 0x4010 appartiene al segmento 1. L'offset rispetto alla base virtuale è 0x4010 - 0x3000 = 0x1010. Indirizzo fisico = 0x100000 + 0x1010 = 0x10001010.",
        },
        {
          domanda:
            "Perché in dumbvm la memoria fisica è allocata in multipli della dimensione di pagina, anche se lo schema è contiguo?",
          risposta:
            "Perché l'MMU del MIPS usa un TLB, quindi la traduzione logico-fisica richiede pagine",
          spiegazione:
            "La traduzione degli indirizzi logici in fisici è gestita dal TLB, che opera a livello di pagina. Per questo motivo, anche se l’allocazione è contigua, la memoria è gestita in unità di pagina. Le altre motivazioni sono errate: l’allocazione a pagina può aumentare la frammentazione, dumbvm non usa una page table, e kmalloc può richiedere qualsiasi dimensione.",
        },
      ];
      const eserciziList = document.getElementById("esercizi-list");
      const esameSelect = document.getElementById("esame-select");

      function renderEsercizi(esame) {
        eserciziList.innerHTML = "";
        let gruppoDiv = document.createElement("div");
        let eserciziDaMostrare = [];
        let titolo = "";
        if (esame === "settembre2024") {
          titolo = "Appello Settembre 2024";
          eserciziDaMostrare = eserciziSettembre2024;
        } else if (esame === "gennaio2025") {
          titolo = "Appello Gennaio 2025";
          eserciziDaMostrare = eserciziGennaio2025;
        } else if (esame === "giugno2024") {
          titolo = "Appello Giugno 2024";
          eserciziDaMostrare = eserciziGiugno2024;
        } else if (esame === "luglio2016") {
          titolo = "Appello Luglio 2016";
          eserciziDaMostrare = eserciziLuglio2016Section;
        } else if (esame === "lab2") {
          titolo = "Laboratorio #2";
        }
        gruppoDiv.innerHTML = `<h2 style=\"color:${
          esame === "lab2" ? "#e67e22" : "#2980b9"
        };margin-top:2rem;\">${titolo}</h2>`;
        eserciziList.appendChild(gruppoDiv);
        if (esame === "lab2") {
          eserciziLab2.forEach((item, idx) => {
            if (item.riassunto) {
              // Card riassunto
              const riassunto = document.createElement("div");
              riassunto.className = "esercizio-card";
              riassunto.innerHTML = `
                <div class=\"esercizio-header\" tabindex=\"0\" role=\"button\" aria-expanded=\"true\">\n      <span>Riassunto OS/161</span>\n      <span class=\"arrow\">&#9660;</span>\n    </div>\n    <div class=\"esercizio-content\" style=\"display:block;\">\n      <div style=\"padding:0.5em 0 0.5em 0.5em;\">\n        <b>Gestione memoria</b><ul style=\"margin-top:0.2em;\"><li><b>Traduzione e TLB:</b> ${
                  item.riassunto.gestione_memoria.traduzione_e_tlb
                    .spazio_indirizzi
                }. Zone kernel: ${item.riassunto.gestione_memoria.traduzione_e_tlb.zone_kernel.join(
                ", "
              )}. TLB: ${
                item.riassunto.gestione_memoria.traduzione_e_tlb.tlb
              }.</li><li><b>dumbvm addrspace:</b> ${
                item.riassunto.gestione_memoria.dumbvm_addrspace.descrizione
              }. Segmenti: ${item.riassunto.gestione_memoria.dumbvm_addrspace.segmenti.join(
                ", "
              )}. Stack: ${
                item.riassunto.gestione_memoria.dumbvm_addrspace.stack
              }.</li><li><b>Allocazione memoria:</b> ${item.riassunto.gestione_memoria.allocazione_memoria.funzioni.join(
                "; "
              )}.</li><li><b>Rilascio memoria:</b> ${
                item.riassunto.gestione_memoria.rilascio_memoria.note
              }; Bitmap: freeRamFrames (${
                item.riassunto.gestione_memoria.rilascio_memoria.bitmap
                  .freeRamFrames
              }), allocSize (${
                item.riassunto.gestione_memoria.rilascio_memoria.bitmap
                  .allocSize
              }). Funzioni: ${item.riassunto.gestione_memoria.rilascio_memoria.funzioni.join(
                "; "
              )}.</li></ul>
        <b>System call</b><ul style=\"margin-top:0.2em;\"><li><b>Meccanismo:</b> ${
          item.riassunto.system_call.meccanismo.trap
        }, ${item.riassunto.system_call.meccanismo.trapframe}, ${
                item.riassunto.system_call.meccanismo.syscall_dispatch
              }.</li><li><b>Implementate:</b> ${item.riassunto.system_call.syscall_implementate.join(
                "; "
              )}.</li></ul>
        <b>Funzioni chiave:</b> ${item.riassunto.funzioni_chiave.join(
          ", "
        )}.<br/>
        <b>Sincronizzazione:</b> ${item.riassunto.sincronizzazione.join(
          ", "
        )}.<br/>
        <b>Strutture dati:</b> ${item.riassunto.strutture_dati.join(", ")}.
      </div>\n    </div>\n  `;
              eserciziList.appendChild(riassunto);
            }
            if (item.codice) {
              // Card codice
              const card = document.createElement("div");
              card.className = "esercizio-card";
              card.innerHTML = `
                <div class=\"esercizio-header\" tabindex=\"0\" role=\"button\" aria-expanded=\"true\">\n      <span>Codice</span>\n      <span class=\"arrow\">&#9660;</span>\n    </div>\n    <div class=\"esercizio-content\" style=\"display:block;\">\n      <pre style=\"background:#f4f4f4;padding:1em;border-radius:4px;overflow-x:auto;\"><code>${item.codice
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")}</code></pre>\n    </div>\n  `;
              eserciziList.appendChild(card);
              // Domande
              item.domande.forEach((ex, didx) => {
                const domandaCard = document.createElement("div");
                domandaCard.className = "esercizio-card";
                domandaCard.innerHTML = `
                  <div class=\"esercizio-header\" tabindex=\"0\" role=\"button\" aria-expanded=\"false\">\n      <span>DOMANDA ${
                    didx + 1
                  }</span>\n      <span class=\"arrow\">&#9654;</span>\n    </div>\n    <div class=\"esercizio-content\">\n      <div class=\"domanda\">${
                  ex.domanda
                }</div>\n      <div class=\"risposta\">Risposta: ${
                  ex.risposta
                }</div>\n      <div class=\"spiegazione\">${
                  ex.soluzione
                }</div>\n    </div>\n  `;
                const header = domandaCard.querySelector(".esercizio-header");
                const content = domandaCard.querySelector(".esercizio-content");
                const arrow = domandaCard.querySelector(".arrow");
                content.style.display = "none";
                header.addEventListener("click", function () {
                  const expanded = content.style.display === "block";
                  content.style.display = expanded ? "none" : "block";
                  arrow.innerHTML = expanded ? "&#9654;" : "&#9660;";
                  header.setAttribute("aria-expanded", !expanded);
                });
                header.addEventListener("keypress", function (e) {
                  if (e.key === "Enter" || e.key === " ") {
                    header.click();
                  }
                });
                eserciziList.appendChild(domandaCard);
              });
            }
          });
        } else {
          eserciziDaMostrare.forEach((ex, idx) => {
            const card = document.createElement("div");
            card.className = "esercizio-card";
            card.innerHTML = `
            <div class=\"esercizio-header\" tabindex=\"0\" role=\"button\" aria-expanded=\"false\">\n      <span>ESERCIZIO ${
              idx + 1
            }</span>\n      <span class=\"arrow\">&#9654;</span>\n    </div>\n    <div class=\"esercizio-content\">\n      <div class=\"domanda\">${
              ex.domanda
            }</div>\n      <div class=\"risposta\">Risposta: ${
              ex.risposta
            }</div>\n      <div class=\"spiegazione\">${
              ex.spiegazione
            }</div>\n    </div>\n  `;
            const header = card.querySelector(".esercizio-header");
            const content = card.querySelector(".esercizio-content");
            const arrow = card.querySelector(".arrow");
            content.style.display = "none";
            header.addEventListener("click", function () {
              const expanded = content.style.display === "block";
              content.style.display = expanded ? "none" : "block";
              arrow.innerHTML = expanded ? "&#9654;" : "&#9660;";
              header.setAttribute("aria-expanded", !expanded);
            });
            header.addEventListener("keypress", function (e) {
              if (e.key === "Enter" || e.key === " ") {
                header.click();
              }
            });
            eserciziList.appendChild(card);
          });
        }
      }

      esameSelect.addEventListener("change", function (e) {
        renderEsercizi(e.target.value);
        aggiornaCompletatoLabel();
      });
      // Mostra di default settembre 2024
      renderEsercizi("settembre2024");
      aggiornaCompletatoLabel();

      // Bottone Completato
      const completatoBtn = document.getElementById("completato-btn");
      // L'handler del bottone viene gestito dinamicamente in aggiornaCompletatoLabel
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>Esercizi OS/161 - Gestione Memoria</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
        background-color: #f9f9f9;
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 2rem;
      }
      #esercizi-list {
        max-width: 800px;
        margin: 0 auto;
      }
      .esercizio-card {
        background: #fff;
        border-left: 5px solid #3498db;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
        padding: 0;
        border-radius: 6px;
        overflow: hidden;
      }
      .esercizio-header {
        cursor: pointer;
        padding: 1rem;
        font-weight: bold;
        background: #eaf6fb;
        display: flex;
        justify-content: space-between;
        align-items: center;
        outline: none;
      }
      .esercizio-header:focus {
        box-shadow: 0 0 0 2px #3498db;
      }
      .arrow {
        font-size: 1.2em;
        transition: transform 0.2s;
      }
      .esercizio-content {
        padding: 1rem;
        border-top: 1px solid #eee;
        display: none;
      }
      .domanda {
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .risposta {
        color: #27ae60;
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .spiegazione {
        margin-top: 0.5rem;
      }
    </style>
  </head>
  <body>
    <h1>Esercizi OS/161 - Gestione Memoria</h1>
    <label for="esame-select" style="font-weight: bold; margin-right: 1rem"
      >Seleziona esame:</label
    >
    <select id="esame-select" style="margin-bottom: 2rem">
      <option value="settembre2024">Appello Settembre 2024</option>
      <option value="gennaio2025">Appello Gennaio 2025</option>
      <option value="giugno2024">Appello Giugno 2024</option>
    </select>
    <div id="esercizi-list"></div>
    <noscript>
      <p>
        Abilita JavaScript per visualizzare gli esercizi in modo interattivo.
      </p>
    </noscript>
    <script>
      const esercizi = [
        {
          domanda:
            "Sebbene la soluzione proposta per supportare la deallocazione della memoria (freeppages) sia basata su una bitmap, potrebbe essere utilizzata anche una lista concatenata.",
          risposta: "TRUE",
          spiegazione:
            "Una lista concatenata è un'alternativa possibile alla bitmap per gestire i blocchi di memoria libera, anche se meno efficiente in termini di accesso e frammentazione. OS/161 usa una bitmap, ma una linked list sarebbe concettualmente valida.",
        },
        {
          domanda:
            "La funzione ram_stealmem alloca in modo incrementale la memoria a partire dal primo indirizzo disponibile dopo aver fatto load del kernel.",
          risposta: "TRUE",
          spiegazione:
            "ram_stealmem alloca memoria in modo grezzo e lineare, partendo dall’indirizzo subito dopo la fine del kernel, senza supportare la deallocazione. È usata solo all'inizio, prima dell'inizializzazione completa della gestione della memoria.",
        },
        {
          domanda:
            "Quando si utilizza una bitmap per tenere traccia della RAM allocata/libera, è necessario un secondo array che memorizzi le dimensioni delle partizioni allocate per l'allocazione sia della memoria dinamica del kernel che dei processi utente.",
          risposta: "FALSE",
          spiegazione:
            "Una bitmap tiene traccia dello stato di ciascun frame (libero/occupato), ma non richiede necessariamente un secondo array per le dimensioni delle allocazioni. Le dimensioni vengono gestite logicamente dal gestore della memoria, non servono strutture separate in questo caso.",
        },
        {
          domanda:
            "Lo stack di un processo utente non viene allocato (in dumbvm) chiamando ram_stealmem, perché la dimensione dello stack è una costante e lo stack si trova sempre agli stessi indirizzi logici.",
          risposta: "FALSE",
          spiegazione:
            "In dumbvm, lo stack viene comunque allocato in RAM con ram_stealmem, come ogni altra parte della memoria utente (stack, heap, text, data). Il fatto che abbia un indirizzo logico fisso non implica che non serva l’allocazione fisica.",
        },
        {
          domanda:
            "Lo schema di allocazione utilizzato da ram_stealmem non consentirà l'intercalare partizioni contigue del kernel e dei processi user (in altre parole, le partizioni del kernel e le partizioni user non saranno mai interlacciate).",
          risposta: "FALSE",
          spiegazione:
            "Poiché ram_stealmem alloca memoria in modo sequenziale prima che il sistema sia completamente operativo, non è garantita alcuna separazione o intercalazione strutturata tra memoria kernel e user. Anzi, possono trovarsi mescolate in memoria fisica.",
        },
        {
          domanda:
            "La funzione ram_stealmem viene chiamata per l'allocazione della memoria sia del kernel (memoria dinamica) che dei processi user.",
          risposta: "TRUE",
          spiegazione:
            "In OS/161, prima che sia inizializzato un sistema più avanzato di gestione della memoria (es. con freeppages o bitmap), sia la memoria dinamica del kernel che quella utente vengono allocate tramite ram_stealmem.",
        },
        {
          domanda: "Convertire l'indirizzo logico 0x8110 in indirizzo fisico",
          risposta: "0x201110",
          spiegazione:
            "L'indirizzo 0x8110 rientra nel primo segmento dello spazio utente, che inizia da as_vbase1 = 0x3000 e si estende per 3 pagine da 4 KB, quindi fino a 0xF000. Essendo 0x8110 compreso tra 0x3000 e 0xF000, si trova in questo intervallo. Il corrispondente indirizzo fisico si ottiene sommando all'indirizzo base fisico as_pbase1 = 0x200000 l'offset dell'indirizzo virtuale all'interno del segmento: 0x8110 - 0x3000 = 0x5110. Quindi l'indirizzo fisico è 0x200000 + 0x5110 = 0x201110.",
        },
        {
          domanda: "Convertire l'indirizzo logico 0x6500 in indirizzo fisico",
          risposta: "0x80006500 (fuori dallo user space)",
          spiegazione:
            "L'indirizzo 0x6500 non appartiene a nessuno dei due segmenti utente: non è compreso né tra 0x3000 e 0xF000 (primo segmento), né tra 0x7000 e 0x17000 (secondo segmento). In OS/161, se un indirizzo non rientra nello spazio utente e non appartiene a una regione valida, viene considerato appartenente al kernel. In dumbvm, gli indirizzi del kernel sono mappati 1:1, quindi 0x6500 è interpretato come fisico nel kernel space → 0x80006500.",
        },
        {
          domanda:
            "Convertire l'indirizzo logico 0x7FFFE010 in indirizzo fisico",
          risposta: "0x3FE010",
          spiegazione:
            "L'indirizzo 0x7FFFE010 si trova nello spazio di stack utente. In dumbvm, lo stack utente occupa le ultime 18 pagine da 4 KB prima dell'indirizzo USERSTACK = 0x80000000. Quindi lo stack inizia a 0x80000000 - 18×4096 = 0x7FFFC000. Poiché 0x7FFFE010 è compreso tra 0x7FFFC000 e 0x80000000, appartiene allo stack. Il base fisico dello stack è as_stackpbase = 0x400000, e l'offset è 0x7FFFE010 - 0x7FFFC000 = 0x2010. Sommando: 0x400000 + 0x2010 = 0x3FE010.",
        },
        {
          domanda:
            "Convertire l'indirizzo logico 0x805000B0 in indirizzo fisico",
          risposta: "0x5000B0",
          spiegazione:
            "L'indirizzo 0x805000B0 si trova nello spazio del kernel, poiché è maggiore di 0x80000000. In dumbvm, lo spazio del kernel è mappato 1:1, cioè l'indirizzo fisico corrisponde all'indirizzo logico meno 0x80000000. Calcolando: 0x805000B0 - 0x80000000 = 0x5000B0.",
        },
      ];
      const eserciziSettembre2024 = esercizi.slice(0, 10);
      // Nuova sezione Gennaio 2025
      const eserciziGennaio2025 = [
        {
          domanda:
            "Le modifiche a conf.kern + esecuzione di ./config PROJECT sono sufficienti per compilare syscall/project.c con bmake depend + bmake?",
          risposta: "No",
          spiegazione:
            "Le modifiche definiscono l'opzione e il file opzionale, ma affinché il file venga effettivamente compilato, l'opzione deve essere abilitata esplicitamente nel file PROJECT con la direttiva 'options project'.",
        },
        {
          domanda:
            "Quale file viene generato da ./config PROJECT? È sempre generato o solo se 'options project' è presente in PROJECT?",
          risposta: "opt-project.h (sempre generato)",
          spiegazione:
            "Il file viene generato automaticamente se 'conf.kern' contiene 'defoption project', anche se 'options project' non è presente nel file PROJECT.",
        },
        {
          domanda: "Cosa contiene il file opt-project.h?",
          risposta: "#define OPT_PROJECT 1 oppure #define OPT_PROJECT 0",
          spiegazione:
            "Include anche la protezione contro inclusioni multiple. Il valore 1 o 0 dipende dalla presenza o assenza della riga 'options project' nel file PROJECT.",
        },
        {
          domanda:
            "Come si può compilare project_init() in main.c solo se l’opzione project è attiva?",
          risposta:
            '#include "opt-project.h" seguito da #if OPT_PROJECT project_init(); #endif',
          spiegazione:
            "La macro OPT_PROJECT, definita in opt-project.h, consente di includere codice solo quando l’opzione è abilitata.",
        },
      ];
      const eserciziGiugno2024 = [
        {
          domanda:
            "L'indirizzo 0x80803005 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico kernel",
          spiegazione:
            "Non può essere un indirizzo logico utente perché è > 2GB. Non può essere un indirizzo fisico perché è maggiore di 4MB (la RAM disponibile). Può essere un indirizzo logico del kernel, ma nel contesto specifico non è compatibile con la RAM disponibile, che termina a 0x80400000.",
        },
        {
          domanda:
            "L'indirizzo 0x312010 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico utente o indirizzo fisico",
          spiegazione:
            "L'indirizzo è < 2GB, quindi valido come indirizzo logico utente. È anche < 4MB, quindi può essere un indirizzo fisico valido. Non può essere un indirizzo logico del kernel perché è al di sotto del limite minimo del kernel (0x80000000).",
        },
        {
          domanda:
            "L'indirizzo 0x532100 può essere un indirizzo logico utente, un indirizzo logico kernel o un indirizzo fisico?",
          risposta: "Indirizzo logico utente",
          spiegazione:
            "È < 2GB, quindi può essere un indirizzo logico utente. Tuttavia è > 4MB, quindi non può essere un indirizzo fisico (dato che la RAM ha solo 4MB). Non è un indirizzo logico del kernel, poiché è < 0x80000000.",
        },
        {
          domanda:
            "Dato l'indirizzo logico utente 0x4010, calcolare l'indirizzo fisico corrispondente usando: as_pbase1 = 0x100000, as_pbase2 = 0x200000, as_vbase1 = 0x3000, as_vbase2 = 0x6000, as_npages1 = 2, as_npages2 = 4",
          risposta: "0x10001010",
          spiegazione:
            "Le pagine in OS/161 sono da 4KB (12 bit di offset). L'indirizzo 0x4010 appartiene alla pagina 4 ed ha un offset di 0x10. Il primo segmento utente parte da 0x3000 e ha 2 pagine (fino a 0x7000), quindi 0x4010 appartiene al segmento 1. L'offset rispetto alla base virtuale è 0x4010 - 0x3000 = 0x1010. Indirizzo fisico = 0x100000 + 0x1010 = 0x10001010.",
        },
        {
          domanda:
            "Perché in dumbvm la memoria fisica è allocata in multipli della dimensione di pagina, anche se lo schema è contiguo?",
          risposta:
            "Perché l'MMU del MIPS usa un TLB, quindi la traduzione logico-fisica richiede pagine",
          spiegazione:
            "La traduzione degli indirizzi logici in fisici è gestita dal TLB, che opera a livello di pagina. Per questo motivo, anche se l’allocazione è contigua, la memoria è gestita in unità di pagina. Le altre motivazioni sono errate: l’allocazione a pagina può aumentare la frammentazione, dumbvm non usa una page table, e kmalloc può richiedere qualsiasi dimensione.",
        },
      ];
      const eserciziList = document.getElementById("esercizi-list");
      const esameSelect = document.getElementById("esame-select");

      function renderEsercizi(esame) {
        eserciziList.innerHTML = "";
        let gruppoDiv = document.createElement("div");
        let eserciziDaMostrare = [];
        let titolo = "";
        if (esame === "settembre2024") {
          titolo = "Appello Settembre 2024";
          eserciziDaMostrare = eserciziSettembre2024;
        } else if (esame === "gennaio2025") {
          titolo = "Appello Gennaio 2025";
          eserciziDaMostrare = eserciziGennaio2025;
        } else {
          titolo = "Appello Giugno 2024";
          eserciziDaMostrare = eserciziGiugno2024;
        }
        gruppoDiv.innerHTML = `<h2 style=\"color:#2980b9;margin-top:2rem;\">${titolo}</h2>`;
        eserciziList.appendChild(gruppoDiv);
        eserciziDaMostrare.forEach((ex, idx) => {
          const card = document.createElement("div");
          card.className = "esercizio-card";
          card.innerHTML = `
          <div class=\"esercizio-header\" tabindex=\"0\" role=\"button\" aria-expanded=\"false\">\n      <span>ESERCIZIO ${
            idx + 1
          }</span>\n      <span class=\"arrow\">&#9654;</span>\n    </div>\n    <div class=\"esercizio-content\">\n      <div class=\"domanda\">${
            ex.domanda
          }</div>\n      <div class=\"risposta\">Risposta: ${
            ex.risposta
          }</div>\n      <div class=\"spiegazione\">${
            ex.spiegazione
          }</div>\n    </div>\n  `;
          const header = card.querySelector(".esercizio-header");
          const content = card.querySelector(".esercizio-content");
          const arrow = card.querySelector(".arrow");
          content.style.display = "none";
          header.addEventListener("click", function () {
            const expanded = content.style.display === "block";
            content.style.display = expanded ? "none" : "block";
            arrow.innerHTML = expanded ? "&#9654;" : "&#9660;";
            header.setAttribute("aria-expanded", !expanded);
          });
          header.addEventListener("keypress", function (e) {
            if (e.key === "Enter" || e.key === " ") {
              header.click();
            }
          });
          eserciziList.appendChild(card);
        });
      }

      esameSelect.addEventListener("change", function (e) {
        renderEsercizi(e.target.value);
      });
      // Mostra di default settembre 2024
      renderEsercizi("settembre2024");
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>Esercizi Sistemi Operativi - Memoria Virtuale</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
        background-color: #f9f9f9;
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 2rem;
      }
      #esercizi-list {
        max-width: 800px;
        margin: 0 auto;
      }
      .esercizio-card {
        background: #fff;
        border-left: 5px solid #3498db;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
        padding: 0;
        border-radius: 6px;
        overflow: hidden;
      }
      .esercizio-header {
        cursor: pointer;
        padding: 1rem;
        font-weight: bold;
        background: #eaf6fb;
        display: flex;
        justify-content: space-between;
        align-items: center;
        outline: none;
      }
      .esercizio-header:focus {
        box-shadow: 0 0 0 2px #3498db;
      }
      .arrow {
        font-size: 1.2em;
        transition: transform 0.2s;
      }
      .esercizio-content {
        padding: 1rem;
        border-top: 1px solid #eee;
        display: none;
      }
      .domanda {
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .risposta {
        color: #27ae60;
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .spiegazione {
        margin-top: 0.5rem;
      }
    </style>
  </head>
  <body>
    <h1>Esercizi Sistemi Operativi - Memoria Virtuale</h1>
    <label
      for="scheda-select"
      style="font-weight: bold; margin-bottom: 1rem; display: block"
      >Seleziona scheda esercizi:</label
    >
    <select id="scheda-select" style="margin-bottom: 2rem">
      <option value="giugno">Appello Giugno 2024</option>
      <option value="settembre">Appello Settembre 2024</option>
    </select>
    <div id="esercizi-list"></div>
    <noscript>
      <p>
        Abilita JavaScript per visualizzare gli esercizi in modo interattivo.
      </p>
    </noscript>
    <script>
      // Esercizi giugno 2024 (primi 4)
      const eserciziGiugno = [
        {
          domanda:
            "La politica di rimpiazzamento delle pagine basata sul working set è una politica a dimensione fissa?",
          risposta: "NO",
          spiegazione:
            "La dimensione del working set (insieme residente) cambia dinamicamente in base alle pagine accedute nella finestra temporale Delta, quindi non è fissa.",
        },
        {
          domanda:
            "Perché è difficile implementare la politica del working set?",
          risposta: [
            "Perché l'insieme residente va aggiornato anche in assenza di page fault",
            "Perché la tecnica richiede di memorizzare il tempo dell’ultimo accesso per ogni pagina",
          ],
          spiegazione:
            "Non è difficile scegliere un buon Delta: il valore influenza solo le prestazioni. Non è necessario mantenere una lista completa degli accessi, basta l'ultimo accesso. La difficoltà sta nel dover aggiornare il working set anche quando non ci sono page fault, e nel dover tenere traccia del tempo dell'ultimo accesso per ogni pagina.",
        },
        {
          domanda:
            "Considera una strategia LRU basata su pila (stack) con 5 frame. Dato il reference string: 4, 6, 4, 1, 7, 8, 2, 2, 3 (T1), 4, 2 (T2). Rappresenta lo stack al tempo T1 (dopo il riferimento a 3) e T2 (dopo il secondo riferimento a 2).",
          risposta: {
            T1: "3,2,8,7,1",
            T2: "2,4,3,2,8",
          },
          spiegazione:
            "La pila viene aggiornata spostando in cima la pagina più recentemente usata. A T1 la pila contiene: 3,2,8,7,1. Dopo l'accesso alla pagina 4 e poi a 2 (T2), la pila diventa: 2,4,3,2,8.",
        },
        {
          domanda:
            "Due sequenze di riferimento w1 e w2 (di uguale lunghezza) vengono valutate con due algoritmi di rimpiazzamento A1 e A2, con p2 = 2*p1. A1 produce lo stesso numero di page fault (5000) per entrambe le sequenze. A2 produce un numero diverso di fault per w1 e w2, ma la somma è 10000. Se A1 ha una frequenza di page fault del 20% superiore rispetto ad A2, calcola F1 e F2 di A2.",
          risposta: {
            F1_A2: 2500,
            F2_A2: 7500,
          },
          spiegazione:
            "Sappiamo che F(A1) = p1 * (5000 + 2 * 5000) = 15000 * p1. Dato che F(A1) è il 20% in più di F(A2), allora: 1.2 * (x + 2y) = 15000 → x + 2y = 12500. Insieme a x + y = 10000, risolvendo il sistema otteniamo: x = 2500 e y = 7500.",
        },
        {
          domanda:
            "Un file binario di dimensione 23033 KB è memorizzato in un file system con allocazione indicizzata e blocchi di 4KB. Calcolare il numero esatto di blocchi dati e blocchi indice utilizzati, e la frammentazione interna per entrambi.",
          risposta: {
            blocchi_dati: 5759,
            blocchi_indice: 6,
            frammentazione_interna_dati: "3KB",
            frammentazione_interna_indici: "1516B",
          },
          spiegazione:
            "Ogni blocco dati è di 4KB, quindi servono ceil(23033KB / 4KB) = 5759 blocchi dati. L’ultimo blocco dati è riempito solo al 25%, quindi la frammentazione interna nei dati è 0.75 * 4KB = 3KB. Ogni blocco indice può contenere 1023 puntatori (4096 / 1024) a blocchi dati, più uno per collegare il blocco indice successivo. Per contenere 5759 blocchi dati servono ceil(5759 / 1023) = 6 blocchi indice. La frammentazione interna nei blocchi indice è data dagli slot non usati: 6 * 1023 - 5759 = 379 slot inutilizzati → 379 * 4B = 1516B.",
        },
        {
          domanda:
            "Un file di testo di 15300 byte contiene linee di lunghezza variabile, ognuna terminata da ‘\\n’. La lunghezza media è di 50 caratteri (escluso ‘\\n’), e la lunghezza massima è 100. Quante righe contiene il file?",
          risposta: 300,
          spiegazione:
            "La lunghezza media effettiva di ogni riga è 51 byte (50 caratteri + 1 carattere ‘\\n’). Quindi: numero di righe = 15300 / 51 = 300 righe esatte. Non è necessario indicare un intervallo minimo/massimo.",
        },
        {
          domanda:
            "Nel file precedente (B), la presenza di righe di lunghezza variabile influisce sulla strategia di allocazione del file system?",
          risposta: "NO",
          spiegazione:
            "L’allocazione dei blocchi su disco è gestita dal file system ed è indipendente dalla struttura del contenuto del file. Che il file contenga righe fisse o variabili, l’allocazione è fatta a blocchi di dimensione fissa.",
        },
        {
          domanda:
            "Tutti i blocchi allocati contengono lo stesso numero di righe, calcolabile come dimensione del blocco diviso la lunghezza massima della riga?",
          risposta: "NO",
          spiegazione:
            "Il numero di righe per blocco dipende dalla lunghezza reale delle righe, che è variabile. Anche se il massimo è 100, alcune righe possono essere più corte. Inoltre, questa è una questione di livello applicativo: il file system gestisce blocchi di byte, non righe di testo.",
        },
        {
          domanda:
            "La reach del TLB diminuisce quando aumenta la dimensione della pagina?",
          risposta: "NO",
          spiegazione:
            "La reach del TLB, cioè la quantità di memoria virtuale che può essere mappata tramite il TLB, aumenta con l’aumentare della dimensione delle pagine, perché il numero di entry nel TLB resta fisso, ma ciascuna entry copre una porzione maggiore di memoria.",
        },
        {
          domanda:
            "La frammentazione aumenta quando aumenta la dimensione della pagina, perché sono necessarie partizioni contigue più grandi?",
          risposta: "NO",
          spiegazione:
            "La frammentazione interna effettivamente aumenta con pagine più grandi, ma la motivazione indicata è errata: nella paginazione non c'è allocazione contigua, quindi il problema non dipende da partizioni contigue.",
        },
        {
          domanda:
            "Il prepaging è utile solo se la probabilità che una pagina pre-caricata venga realmente usata è superiore all'80%?",
          risposta: "NO",
          spiegazione:
            "Il prepaging è utile quando le pagine pre-caricate hanno un’alta probabilità di essere usate, ma non esiste una soglia fissa del tipo 'superiore all'80%'.",
        },
        {
          domanda:
            "Tutte le strutture dati del kernel richiedono allocazione contigua?",
          risposta: "NO",
          spiegazione:
            "Solo alcune strutture del kernel richiedono allocazione contigua (per efficienza o per vincoli hardware), come ad esempio la tabella delle pagine. Molte altre strutture possono essere allocate in modo non contiguo.",
        },
        {
          domanda: "L’allocatore slab usa solo dimensioni pari a potenze di 2?",
          risposta: "NO",
          spiegazione:
            "L’allocatore buddy utilizza taglie pari a potenze di 2. Lo slab allocator invece è progettato per ridurre la frammentazione e può usare dimensioni arbitrarie basate sugli oggetti richiesti.",
        },
        {
          domanda:
            "Una free list di pagine ha in media una frammentazione interna pari a mezza pagina?",
          risposta: "NO",
          spiegazione:
            "Le free list non contengono dati, ma solo riferimenti a pagine libere. Quindi non introducono frammentazione interna: rappresentano solo spazio disponibile.",
        },
      ];
      // Esercizi settembre 2024 (tutti gli altri)
      const eserciziSettembre = [
        {
          domanda:
            "In un sistema di memoria virtuale con un grado fisso di multiprogrammazione, il thrashing può verificarsi anche se la somma dei working set di tutti i processi è inferiore alla memoria fisica disponibile, ma l'algoritmo di sostituzione della pagina non è ottimizzato?",
          risposta: "YES",
          spiegazione:
            "Il thrashing può comunque verificarsi se l'algoritmo di sostituzione delle pagine non tiene conto dei working set o causa sostituzioni frequenti e non necessarie. Anche con memoria sufficiente, un cattivo algoritmo può degradare le prestazioni.",
        },
        {
          domanda:
            "In un sistema con paginazione basata su inverted page table (IPT), è possibile che più pagine virtuali di processi diversi condividano una singola entry della tabella delle pagine senza causare un conflitto nella traduzione degli indirizzi?",
          risposta: "YES",
          spiegazione:
            "L'IPT utilizza una singola entry per ogni frame fisico e include anche l'ID del processo. Quindi, anche se due pagine virtuali diverse condividono un frame, la tabella può distinguerle grazie al PID e non si verifica conflitto.",
        },
        {
          domanda:
            "In un sistema di paginazione a richiesta che utilizza la sostituzione delle pagine locale (a un singolo processo), un processo con frequenza di page fault molto elevata può comunque causare una riduzione della memoria fisica disponibile per altri processi?",
          risposta: "NO",
          spiegazione:
            "La sostituzione locale limita l'uso della memoria fisica da parte del processo alle sue proprie pagine. Anche se il processo ha molti page fault, non può 'rubare' frame ad altri processi, quindi non riduce la memoria disponibile per loro.",
        },
        {
          domanda:
            "Si consideri un sistema a 64 bit con uno spazio di indirizzi virtuale di 2^64 Byte, una dimensione di pagina di 4 KB e 16 GB di memoria fisica. Si supponga che il sistema utilizzi una Inverted Page Table (IPT). Calcolare e spiegare quanto segue:<ol><li>Il numero di bit necessari per il numero di frame fisico.</li><li>Il numero totale di entry nella Inverted Page Table.</li><li>Dato l’indirizzo virtuale <code>0x00007FFFFFFFF000</code>, determinare l’indirizzo fisico se è mappato al frame fisico 1024.</li></ol>",
          risposta: "1) 22 bit, 2) 4M entry, 3) 0x0000000004000000",
          spiegazione: `<strong>1. Numero di bit per frame fisico:</strong><br>La memoria fisica è di 16 GB = 2<sup>34</sup> byte.<br>La dimensione di una pagina è 4 KB = 2<sup>12</sup> byte.<br>Numero di frame fisici = 2<sup>34</sup> / 2<sup>12</sup> = 2<sup>22</sup> = 4M frame.<br>Per identificare ciascun frame servono <strong>22 bit</strong>.<br><br><strong>2. Numero totale di entry nella IPT:</strong><br>L'Inverted Page Table contiene un'entry per ciascun frame fisico.<br>Quindi contiene <strong>2<sup>22</sup> = 4 milioni di entry</strong>.<br><br><strong>3. Traduzione indirizzo virtuale:</strong><br>Indirizzo virtuale: <code>0x00007FFFFFFFF000</code><br>Dimensione pagina = 4 KB = 2<sup>12</sup> → offset = ultimi 12 bit = <code>0x000</code><br>Quindi offset = 0, e il numero di pagina è dato da:<br><code>0x00007FFFFFFFF000 / 0x1000 = 0x00007FFFFFFFF</code> (numero di pagina virtuale)<br>Il frame fisico a cui è mappato è il <strong>1024</strong>-esimo →<br>Indirizzo fisico = <code>1024 * 0x1000 = 0x400000</code><br>Offset = 0 →<br><strong>Indirizzo fisico finale:</strong> <code>0x0000000004000000</code>`,
        },
        {
          domanda:
            "Si consideri un file system che utilizza l'allocazione di tipo <strong>linked</strong>. Il disco è diviso in blocchi di 4 KB, e ogni blocco contiene un puntatore al blocco successivo (4 byte). Un file richiede 5 MB di spazio.<ol><li>Calcolare il numero di blocchi necessari, includendo lo spazio per i puntatori.</li><li>Ricalcolare con puntatori da 2 byte. È più efficiente?</li><li>Confrontare il sovraccarico dei puntatori in entrambi i casi, come percentuale del totale.</li></ol>",
          risposta: `A) 1282 blocchi<br>B) 1281 blocchi, sì, leggermente più efficiente<br>C) Sovraccarico: 5128B (4B), 2562B (2B)`,
          spiegazione: `<strong>A. Calcolo con puntatori da 4 byte:</strong><br>Ogni blocco è di 4096 B, ma 4 B sono riservati al puntatore → 4092 B utili per dati.<br>File = 5 MB = 5 × 1024 × 1024 = 5,242,880 B<br>Numero blocchi = 5,242,880 / 4092 ≈ <strong>1282 blocchi</strong><br><br><strong>B. Calcolo con puntatori da 2 byte:</strong><br>Dati per blocco = 4096 - 2 = 4094 B<br>5,242,880 / 4094 ≈ <strong>1281 blocchi</strong><br>Meno blocchi → meno frammentazione interna → <strong>più efficiente</strong><br><br><strong>C. Sovraccarico in entrambi i casi:</strong><br>- Puntatori da 4 B: 1282 × 4 = <strong>5128 B</strong><br>- Puntatori da 2 B: 1281 × 2 = <strong>2562 B</strong><br>Percentuali:<br>- Caso 1: (5128 / 5,242,880) × 100 ≈ <strong>0.098%</strong><br>- Caso 2: (2562 / 5,242,880) × 100 ≈ <strong>0.049%</strong><br>→ <em>Il sovraccarico si dimezza passando da 4 B a 2 B, anche se in valore assoluto è già molto basso.</em>`,
        },
        {
          domanda:
            "In un sistema con memoria virtuale basata su paginazione a richiesta e DMA, è possibile che si verifichi un page fault durante un trasferimento DMA, causando l'esito negativo del trasferimento se non vengono prese le dovute precauzioni?",
          risposta: "YES",
          spiegazione:
            "Il DMA accede direttamente alla memoria fisica. Se l’indirizzo richiesto non è ancora stato caricato in RAM (page fault), il trasferimento fallisce, a meno che non si usino tecniche come il pinning delle pagine per evitarne lo spostamento.",
        },
        {
          domanda:
            "In un sistema con più dispositivi di I/O e una singola CPU, le operazioni di I/O possono essere eseguite in parallelo se la CPU è occupata nell'esecuzione di un processo?",
          risposta: "YES",
          spiegazione:
            "Le operazioni di I/O possono procedere in parallelo grazie a meccanismi come il DMA o l’I/O asincrono. La CPU può continuare a eseguire altri processi mentre i dispositivi gestiscono autonomamente i trasferimenti.",
        },
        {
          domanda:
            "In un sistema che utilizza I/O basato su interrupt, è possibile che un interrupt venga perso se il controller di interrupt è occupato nell'elaborazione di un altro interrupt e il dispositivo che ha attivato il secondo interrupt non supporta l'accodamento degli interrupt?",
          risposta: "YES",
          spiegazione:
            "Se il controller non è in grado di gestire interrupt concorrenti o accodarli, e il dispositivo non supporta il buffering degli interrupt, un secondo interrupt può essere ignorato mentre il primo è ancora in elaborazione.",
        },
        {
          domanda:
            "Prendere in considerazione un'unità disco rigido (HDD) con le seguenti specifiche:<br>· Dimensione del settore: 512 byte<br>· Numero di tracce per faccia: 5.000<br>· Numero di settori per traccia: 300<br>· Numero di piatti a doppia faccia: 6<br>· Velocità di rotazione del piatto: 7.200 giri/min (giri al minuto)<br><ol><li>Calcolare la velocità di trasferimento dati massima possibile in megabyte al secondo (MB/s), supponendo che sia possibile trasferire una traccia di dati per giro.</li><li>Se il disco subisce un arresto anomalo della testina su un piatto, in che modo ciò influisce sulla capacità totale e sulla disponibilità dei dati supponendo che non siano in atto meccanismi RAID o di backup?</li><li>Se il disco ha un tempo di ricerca medio di 4 ms e deve leggere un file da 1 GB suddiviso in 200 tracce non contigue, calcolare il tempo totale necessario per leggere il file. Includi il tempo per la ricerca, la latenza rotazionale e il trasferimento dei dati. Si supponga che la latenza rotazionale media sia di 4,165 ms e che sia possibile leggere una traccia per giro.</li></ol>",
          risposta: `1) 17.58 MB/s<br>2) Capacità ridotta a 7.87 GB<br>3) Tempo totale ≈ 8.25 s`,
          spiegazione: `<strong>1. Velocità di trasferimento:</strong><br>Ogni traccia contiene 512B × 300 = 150 KB.<br>Velocità di rotazione: 7.200 giri/min = 120 giri/s dunque 1 giro in 1/120 s = 8.33 ms.<br>150 KB × 120 = <strong>18.000 KB/s</strong> = <strong>17.58 MB/s</strong>.<br><br><strong>2. Arresto testina su un piatto:</strong><br>1 piatto = 150 KB × 5.000 tracce = 732.4 MB.<br>Capacità totale iniziale = 8.58 GB.<br>Capacità ridotta = 8.58 GB - 732.4 MB = <strong>7.87 GB</strong>.<br><br><strong>3. Tempo di lettura file 1 GB su 200 tracce:</strong><br>Tempo di ricerca medio = 4 ms.<br>Latenza rotazionale media = 4.165 ms.<br>Tempo per giro = 8.33 ms.<br>Tempo totale = 200 × (4 + 4.165 + 8.33) = 3.299 s.<br>Nota: 1 GB non può stare in sole 200 tracce, servono circa 583 tracce.<br>Tempo totale per 583 tracce = 583 × (4 + 4.165 + 8.33) ≈ <strong>8.25 s</strong>.<br>Se si leggessero solo 200 tracce: <strong>3.3 s</strong>.<br>La stima dipende dalla reale distribuzione del file sulle tracce.`,
        },
      ];

      function renderEsercizi(esercizi) {
        const eserciziList = document.getElementById("esercizi-list");
        eserciziList.innerHTML = "";
        esercizi.forEach((ex, idx) => {
          const card = document.createElement("div");
          card.className = "esercizio-card";
          let rispostaHtml = "";
          if (typeof ex.risposta === "object" && !Array.isArray(ex.risposta)) {
            rispostaHtml = Object.entries(ex.risposta)
              .map(([k, v]) => `<div><strong>${k}:</strong> ${v}</div>`)
              .join("");
          } else if (Array.isArray(ex.risposta)) {
            rispostaHtml = ex.risposta.map((r) => `<div>${r}</div>`).join("");
          } else {
            rispostaHtml = `Risposta: ${ex.risposta}`;
          }
          card.innerHTML = `
            <div class="esercizio-header" tabindex="0" role="button" aria-expanded="false">
              <span>ESERCIZIO ${idx + 1}</span>
              <span class="arrow">&#9654;</span>
            </div>
            <div class="esercizio-content">
              <div class="domanda">${ex.domanda}</div>
              <div class="risposta">${rispostaHtml}</div>
              <div class="spiegazione">${ex.spiegazione}</div>
            </div>
          `;
          const header = card.querySelector(".esercizio-header");
          const content = card.querySelector(".esercizio-content");
          const arrow = card.querySelector(".arrow");
          content.style.display = "none";
          header.addEventListener("click", function () {
            const expanded = content.style.display === "block";
            content.style.display = expanded ? "none" : "block";
            arrow.innerHTML = expanded ? "&#9654;" : "&#9660;";
            header.setAttribute("aria-expanded", !expanded);
          });
          header.addEventListener("keypress", function (e) {
            if (e.key === "Enter" || e.key === " ") {
              header.click();
            }
          });
          eserciziList.appendChild(card);
        });
      }

      const schedaSelect = document.getElementById("scheda-select");
      function updateScheda() {
        if (schedaSelect.value === "giugno") {
          renderEsercizi(eserciziGiugno);
        } else {
          renderEsercizi(eserciziSettembre);
        }
      }
      schedaSelect.addEventListener("change", updateScheda);
      // Mostra di default la scheda di giugno
      renderEsercizi(eserciziGiugno);
    </script>
  </body>
</html>

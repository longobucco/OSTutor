<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>Flashcard - Gestione Memoria OS</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f9f9f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 2rem;
      }
      .card {
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin: 1rem;
        width: 90%;
        max-width: 600px;
        cursor: pointer;
        transition: background 0.3s;
      }
      .card:hover {
        background: #e6f7ff;
      }
      .question {
        font-weight: bold;
      }
      .answer {
        display: none;
        margin-top: 0.5rem;
      }
      .card.open .answer {
        display: block;
      }
      .section-btn {
        background: #007acc;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        margin: 0.5rem;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.3s;
      }
      .section-btn:hover {
        background: #005999;
      }
      .section-btn.active {
        background: #005999;
      }
    </style>
  </head>
  <body>
    <h1>Flashcard OS</h1>
    <div id="sections">
      <button class="section-btn" data-section="memoria">
        Gestione della Memoria
      </button>
      <button class="section-btn" data-section="thread">
        Gestione dei Thread
      </button>
      <button class="section-btn" data-section="calcoli">
        Calcoli Paging, IPT e EAT
      </button>
      <button class="section-btn" data-section="processi">
        Processi e Memoria Virtuale
      </button>
      <button class="section-btn" data-section="reclaiming">
        Reclaiming Pages e Memoria
      </button>
      <button class="section-btn" data-section="os161">OS161</button>
      <button class="section-btn" data-section="io">
        Gestione I/O e File System
      </button>
      <button class="section-btn" data-section="dischi">
        Dischi, SSD e RAID
      </button>

      <!-- Sezione Memoria -->
      <div id="memoria" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">Quando il prepaging è vantaggioso?</div>
          <div class="answer">
            Quando α (percentuale di pagine utilizzate tra quelle precaricate) è
            sufficientemente alta, così che il costo dei page fault risparmiati
            superi il costo delle pagine inutilmente caricate.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i pro e i contro di usare pagine grandi o piccole in
            memoria virtuale?
          </div>
          <div class="answer">
            Pagine piccole: meno frammentazione interna, ma tabelle più grandi.
            Pagine grandi: meno accessi I/O e meno page fault, ma più
            frammentazione interna.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la TLB Reach e perché è importante?</div>
          <div class="answer">
            È la quantità di memoria coperta dalla TLB: TLB Reach = dimensione
            TLB × dimensione pagina. Se non copre l'insieme di lavoro del
            processo, aumentano i page fault.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come influisce la struttura del programma sulla gestione della
            memoria virtuale?
          </div>
          <div class="answer">
            Esempio: azzerare una matrice per righe genera molti più page fault
            rispetto a farlo per colonne, se ogni riga occupa una pagina.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il pinning di una pagina in memoria?</div>
          <div class="answer">
            È il blocco di una pagina durante l'I/O per evitare che venga
            rimossa dal sistema prima della fine dell’operazione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la gestione della memoria in un sistema operativo?
          </div>
          <div class="answer">
            Allocare, monitorare e liberare la memoria in modo sicuro ed
            efficiente tra i processi, garantendo isolamento e massimizzazione
            dell'utilizzo delle risorse.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la MMU e quale ruolo svolge?</div>
          <div class="answer">
            La MMU (Memory Management Unit) è un dispositivo hardware che
            converte gli indirizzi logici in indirizzi fisici durante
            l'esecuzione, usando ad esempio il registro di rilocazione.
          </div>
        </div>
        <div class="card">
          <div class="question">In cosa consiste il caricamento dinamico?</div>
          <div class="answer">
            È la tecnica che carica in RAM solo le parti del programma al
            momento in cui vengono utilizzate, risparmiando spazio e migliorando
            l'efficienza della memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il collegamento dinamico?</div>
          <div class="answer">
            È un meccanismo in cui il collegamento alle librerie avviene a tempo
            di esecuzione, usando uno stub che carica e collega la routine solo
            quando serve.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è l'allocazione contigua della memoria?
          </div>
          <div class="answer">
            È una tecnica in cui ogni processo occupa una singola partizione
            continua della memoria fisica. È semplice ma soggetta a
            frammentazione esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa si intende per allocazione a partizioni variabili?
          </div>
          <div class="answer">
            È un metodo che adatta dinamicamente la dimensione delle partizioni
            alle esigenze dei processi, riducendo la frammentazione interna ma
            non quella esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono gli algoritmi di allocazione più comuni?
          </div>
          <div class="answer">
            Best-fit, First-fit e Worst-fit. I primi due sono generalmente
            migliori in termini di utilizzo dello spazio e velocità.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si può ridurre la frammentazione esterna?
          </div>
          <div class="answer">
            Attraverso la compattazione, che consiste nel rimescolare la memoria
            per ottenere un unico blocco libero contiguo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la paginazione nella gestione della memoria?
          </div>
          <div class="answer">
            È una tecnica che divide la memoria logica e fisica in blocchi di
            dimensione fissa (pagine e frame) per eliminare la frammentazione
            esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si ottiene l'indirizzo fisico a partire da f e d nella
            paginazione?
          </div>
          <div class="answer">
            I bit meno significativi dell'indirizzo fisico coincidono con
            l'offset d, mentre i più significativi con l'indice del frame f
            trovato nella page table.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la frammentazione interna nella paginazione?
          </div>
          <div class="answer">
            È lo spazio inutilizzato nell'ultima pagina allocata a un processo.
            In media, ammonta a mezzo frame.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa contiene una riga della page table oltre al numero del frame?
          </div>
          <div class="answer">
            Bit di validità, protezione, modifica, riferimento, e cache
            disabled.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali registri gestiscono la page table nella CPU?
          </div>
          <div class="answer">
            Il Page Table Base Register (PTBR) e il Page Table Length Register
            (PTLR).
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la TLB?</div>
          <div class="answer">
            La TLB è una cache veloce nella CPU che memorizza traduzioni recenti
            da indirizzi logici a fisici, riducendo i tempi di accesso.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un TLB hit e un TLB miss?</div>
          <div class="answer">
            Un TLB hit avviene quando la pagina cercata è nella TLB, un miss
            quando non lo è e si deve accedere alla page table.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'EAT (Effective Access Time)?</div>
          <div class="answer">
            È il tempo medio di accesso alla memoria, considerando il tasso di
            hit nel TLB e il tempo di accesso in caso di miss.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene implementata la protezione della memoria nella
            paginazione?
          </div>
          <div class="answer">
            Attraverso bit di protezione associati a ciascun frame e bit di
            validità nelle voci della page table.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa sono le pagine condivise?</div>
          <div class="answer">
            Pagine mappate sullo stesso frame per più processi, usate per codice
            rientrante e condivisibile (es. librerie).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si struttura una page table gerarchica?
          </div>
          <div class="answer">
            È una struttura ad albero: un indirizzo logico è diviso in p1
            (outer), p2 (inner) e offset. Si passa dalla outer table alla inner
            table per trovare il frame.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché si usano più livelli di paginazione?
          </div>
          <div class="answer">
            Per gestire grandi spazi di indirizzi logici evitando tabelle delle
            pagine enormi, suddividendole in più livelli (2, 3 o più).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è una tabella delle pagine hash?</div>
          <div class="answer">
            Una struttura in cui il numero di pagina virtuale è usato come
            chiave di hash per accedere rapidamente alla corrispondente entry
            con numero di frame.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa servono le page table clustered?</div>
          <div class="answer">
            A mappare più pagine (es. 16) per ogni voce, migliorando
            l'efficienza con spazi di indirizzi sparsi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è una tabella delle pagine invertita?</div>
          <div class="answer">
            Una tabella con una voce per ogni frame fisico, che contiene il
            numero di pagina virtuale e il processo proprietario.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il vantaggio della tabella delle pagine invertita?
          </div>
          <div class="answer">
            Riduce l'uso di memoria per le tabelle delle pagine, ma richiede una
            ricerca più lenta (spesso hash).
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa contiene la tabella delle pagine?</div>
          <div class="answer">
            Contiene le corrispondenze tra pagine virtuali e frame fisici. Serve
            a tradurre gli indirizzi logici in indirizzi fisici durante
            l'accesso alla memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si struttura un indirizzo virtuale nella paginazione?
          </div>
          <div class="answer">
            È diviso in due parti: il numero di pagina (page number) e l'offset
            all'interno della pagina.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il resident set?</div>
          <div class="answer">
            È l'insieme delle pagine di memoria virtuale di un processo
            attualmente caricate in RAM.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché la RAM è necessaria per l'esecuzione di un processo?
          </div>
          <div class="answer">
            Perché la CPU può accedere solo alla RAM e ai registri, quindi il
            programma deve essere caricato lì per essere eseguito.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo della cache nella gestione della memoria?
          </div>
          <div class="answer">
            La cache si trova tra CPU e RAM e serve a ridurre la latenza di
            accesso, velocizzando l'esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la funzione dei registri base e limite?
          </div>
          <div class="answer">
            Proteggere la memoria: il registro base indica l'inizio dell'area di
            memoria di un processo, il limite indica la dimensione dell'area.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa accade se due processi sono caricati all'indirizzo 0?
          </div>
          <div class="answer">
            Non possono convivere senza rilocazione: uno dei due deve essere
            spostato, e i suoi riferimenti aggiornati.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la rilocazione automatica?</div>
          <div class="answer">
            A permettere che i programmi credano di essere all'indirizzo 0, ma
            vengano eseguiti da un'altra parte della memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le fasi di binding degli indirizzi?
          </div>
          <div class="answer">
            A tempo di compilazione, a tempo di caricamento e a tempo di
            esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'indirizzo logico?</div>
          <div class="answer">
            È l'indirizzo generato dalla CPU, visibile al programma. È anche
            detto indirizzo virtuale.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'indirizzo fisico?</div>
          <div class="answer">
            È l'indirizzo effettivo usato dalla RAM, calcolato dalla MMU in fase
            di esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In quali casi gli indirizzi logici e fisici coincidono?
          </div>
          <div class="answer">
            Quando il binding avviene a tempo di compilazione o caricamento.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la MMU (Memory Management Unit)?</div>
          <div class="answer">
            È l'unità hardware che traduce gli indirizzi logici in indirizzi
            fisici durante l'esecuzione del programma.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la memoria virtuale e perché è importante?
          </div>
          <div class="answer">
            Permette l'esecuzione di processi più grandi della memoria fisica,
            isolamento tra processi e allocazione non contigua, migliorando
            flessibilità e sicurezza.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la paginazione (paging)?</div>
          <div class="answer">
            Divide la memoria virtuale in pagine e la memoria fisica in frame di
            dimensione fissa. Mappa le pagine ai frame tramite una tabella delle
            pagine, evitando frammentazione esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra indirizzo logico e indirizzo fisico?
          </div>
          <div class="answer">
            L'indirizzo logico è generato dal processo (CPU), mentre l'indirizzo
            fisico è quello reale in RAM. La MMU esegue la traduzione.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la tabella delle pagine?</div>
          <div class="answer">
            Tiene traccia della corrispondenza tra pagine logiche e frame
            fisici, includendo anche bit di controllo (presenza, modifica,
            protezione, ecc.).
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa significa "demand paging"?</div>
          <div class="answer">
            Le pagine sono caricate in RAM solo quando richieste, riducendo
            l'uso iniziale della memoria e accelerando l'avvio dei processi.
          </div>
        </div>
        <div class="card">
          <div class="question">Quando si verifica un page fault?</div>
          <div class="answer">
            Quando un processo accede a una pagina non presente in RAM. Il
            sistema operativo interrompe il processo, carica la pagina da disco,
            aggiorna la tabella e riprende l'esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i principali algoritmi di sostituzione delle pagine?
          </div>
          <div class="answer">
            FIFO: sostituisce la pagina più vecchia. LRU: sostituisce la meno
            recentemente usata. Clock: approssima LRU in modo efficiente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa fa lo swapping in un sistema operativo?
          </div>
          <div class="answer">
            Sposta interi processi tra memoria RAM e disco per liberare spazio,
            utile nei sistemi senza memoria virtuale o con poca RAM.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è lo swapping?</div>
          <div class="answer">
            Tecnica che sposta temporaneamente un processo dalla RAM al backing
            store (disco) per liberare memoria fisica.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il tempo tipico di uno swap in/out?</div>
          <div class="answer">
            Per 100MB su disco a 50MB/s: 2s per lo swap out, 2s per lo swap in,
            totale 4s per lo switch di contesto.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il double buffering nello swapping?</div>
          <div class="answer">
            Tecnica che copia prima i dati in memoria kernel, poi permette lo
            swap, infine trasferisce all'I/O. Utile quando c'è I/O sospeso.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando non è possibile fare swap-out di un processo?
          </div>
          <div class="answer">
            Quando è in stato di wait per un'I/O in corso, poiché l'I/O verrebbe
            eseguito su un processo sbagliato.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è lo swapping with paging?</div>
          <div class="answer">
            Tecnica che swap-out solo alcune pagine del processo, generalmente
            quelle non attive, riducendo il tempo di swap.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si gestiscono i blocchi liberi nella memoria fisica?
          </div>
          <div class="answer">
            Bitmap: array di bit, 1 = occupato, 0 = libero. Elenchi: liste di
            blocchi liberi con indirizzo e dimensione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali tecniche usa il kernel per gestire dinamicamente la memoria?
          </div>
          <div class="answer">
            Buddy System: divide la memoria in potenze di 2. Slab Allocator:
            prealloca oggetti dello stesso tipo per evitare frammentazione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la frammentazione e che tipi esistono?
          </div>
          <div class="answer">
            Interna: spazio inutilizzato dentro i blocchi allocati. Esterna:
            spazio libero tra blocchi non contigui, non riutilizzabile
            efficacemente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si può ottimizzare la gestione della memoria?
          </div>
          <div class="answer">
            Usando TLB, clustering di pagine, allocazione basata su priorità, e
            compressione delle pagine inattive.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è lo slab allocator e a cosa serve?</div>
          <div class="answer">
            È un sistema di allocazione della memoria usato nel kernel per
            gestire oggetti piccoli e frequenti in modo efficiente. Prealloca
            blocchi (slab) contenenti oggetti dello stesso tipo, pronti all’uso
            e riutilizzabili, riducendo la frammentazione e migliorando le
            prestazioni.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In che modo la memoria virtuale aumenta efficienza e flessibilità?
          </div>
          <div class="answer">
            Permette isolamento, protezione, multitasking efficiente, carico
            parziale dei programmi, e gestione ottimizzata delle risorse
            fisiche.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la memoria virtuale?</div>
          <div class="answer">
            È la separazione tra indirizzi logici e fisici: permette che lo
            spazio di indirizzi di un processo sia più grande della RAM fisica
            disponibile.
          </div>
        </div>
        <div class="card">
          <div class="question">Quali vantaggi offre la memoria virtuale?</div>
          <div class="answer">
            Spazio di indirizzamento più ampio, creazione processi più
            efficiente, più processi concorrenti, meno I/O per
            caricare/swappare.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il virtual address space?</div>
          <div class="answer">
            È l'insieme degli indirizzi logici che un processo può usare,
            solitamente contiguo e separato dallo spazio fisico.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la paginazione su richiesta (demand paging)?
          </div>
          <div class="answer">
            È una tecnica che carica le pagine in memoria solo quando sono
            effettivamente richieste da un processo.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un page fault?</div>
          <div class="answer">
            Un errore che si verifica quando si tenta di accedere a una pagina
            non residente in memoria (bit valido = i nella page table).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i vantaggi della paginazione su richiesta?
          </div>
          <div class="answer">
            Meno I/O, meno memoria necessaria, risposta più rapida e più
            processi supportati contemporaneamente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la pura paginazione a richiesta?</div>
          <div class="answer">
            È il caso estremo dove ogni accesso a pagina causa un page fault,
            poiché nessuna pagina è inizialmente residente in RAM.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la località di riferimento?</div>
          <div class="answer">
            Concetto secondo cui un'istruzione può accedere a più pagine
            contigue, riducendo il numero complessivo di page fault.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la lista dei frame liberi?</div>
          <div class="answer">
            Permette di trovare rapidamente un frame libero da usare in caso di
            page fault, ottimizzando la gestione della memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le fasi di gestione di un page fault?
          </div>
          <div class="answer">
            1. Trap, 2. Salvataggio stato, 3. Verifica errore, 4. Controllo
            legalità, 5. Lettura disco, 6. Aggiornamento tabelle, 7. Riavvio
            istruzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i principali schemi di allocazione dei frame?
          </div>
          <div class="answer">Allocazione fissa e allocazione prioritaria.</div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'allocazione proporzionale?</div>
          <div class="answer">
            Frame assegnati in base alla dimensione dell'address space del
            processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra rimpiazzamento globale e locale?
          </div>
          <div class="answer">
            Il rimpiazzamento globale sceglie frame da qualsiasi processo,
            quello locale solo dal processo corrente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la strategia Reclaiming Pages?</div>
          <div class="answer">
            Attiva il page replacement quando i frame liberi scendono sotto una
            soglia prestabilita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è l'accesso alla memoria non uniforme (NUMA)?
          </div>
          <div class="answer">
            In architetture multicore la RAM è divisa in partizioni locali per
            ogni CPU, con tempi di accesso variabili.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il thrashing?</div>
          <div class="answer">
            Condizione in cui il sistema passa più tempo a swappare pagine che a
            eseguire il codice.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il modello Working Set?</div>
          <div class="answer">
            Modello che identifica l'insieme di pagine su cui un processo lavora
            attivamente entro una finestra temporale &Delta;.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona il metodo Page Fault Frequency?
          </div>
          <div class="answer">
            Aggiunge o rimuove frame a un processo in base alla distanza
            temporale tra due page fault (&tau;).
          </div>
        </div>
        <div class="card">
          <div class="question">Come viene gestita la memoria del kernel?</div>
          <div class="answer">
            Con metodi specifici come allocazione contigua, Buddy System o Slab
            Allocator per evitare frammentazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona il Buddy System?</div>
          <div class="answer">
            Alloca memoria in potenze di 2; i blocchi possono essere divisi o
            uniti in "buddy" per ridurre frammentazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è lo Slab Allocator?</div>
          <div class="answer">
            Sistema che gestisce oggetti di dimensione fissa in slab per ridurre
            la frammentazione e velocizzare l'allocazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il prepaging?</div>
          <div class="answer">
            Tecnica che pre-carica alcune pagine prima che vengano referenziate,
            per ridurre i page fault all'avvio.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa succede dopo che si riceve un interrupt di I/O completato
            durante un page fault?
          </div>
          <div class="answer">
            Il sistema corregge le tabelle, attende che la CPU sia riassegnata,
            ripristina lo stato del processo e riprende l'esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è l'EAT (Effective Access Time) in presenza di page fault?
          </div>
          <div class="answer">
            EAT = (1 – p) x tempo accesso memoria + p x (overhead page fault +
            swap out + swap in)
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la Copy-on-Write (COW)?</div>
          <div class="answer">
            Una tecnica in cui padre e figlio condividono inizialmente pagine;
            quando una viene modificata, viene copiata solo allora.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando si usa la tecnica 'zero-fill-on-demand'?
          </div>
          <div class="answer">
            Quando si vogliono allocare frame liberi già azzerati, pronti
            all'uso, provenienti da un pool dedicato.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando viene attivata la sostituzione delle pagine?
          </div>
          <div class="answer">
            Quando non ci sono frame liberi, bisogna scegliere una pagina da
            rimpiazzare per fare spazio.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il compito dell'algoritmo di sostituzione delle pagine?
          </div>
          <div class="answer">
            Minimizzare i page fault scegliendo una pagina che difficilmente
            verrà riutilizzata a breve.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona l'algoritmo FIFO per il page replacement?
          </div>
          <div class="answer">
            Sostituisce la pagina da più tempo in memoria, con struttura a coda
            circolare.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'anomalia di Belady?</div>
          <div class="answer">
            Fenomeno per cui aggiungendo più frame con l'algoritmo FIFO si
            possono avere più page fault.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona l'algoritmo ottimo di page replacement?
          </div>
          <div class="answer">
            Sostituisce la pagina che non verrà usata per più tempo in futuro; è
            teorico e usato come benchmark.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona l'algoritmo LRU?</div>
          <div class="answer">
            Sostituisce la pagina meno recentemente usata, usando contatori o
            stack per tenere traccia.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'algoritmo second-chance?</div>
          <div class="answer">
            Versione approssimata di LRU che dà una seconda possibilità alle
            pagine con bit di riferimento a 1.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'algoritmo Enhanced Second-Chance?</div>
          <div class="answer">
            Usa sia il bit di riferimento sia il bit di modifica per rimpiazzare
            le pagine più 'leggere'.
          </div>
        </div>
        <div class="card">
          <div class="question">Differenza tra LFU e MFU?</div>
          <div class="answer">
            LFU sostituisce la pagina usata meno frequentemente, MFU quella
            usata più frequentemente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il page buffering?</div>
          <div class="answer">
            Mantiene le pagine vittima in un pool per poterle riutilizzare
            rapidamente senza rilettura da disco.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è il doppio buffering nelle applicazioni?
          </div>
          <div class="answer">
            È quando sia il sistema operativo che l'applicazione mantengono una
            copia della pagina in memoria.
          </div>
        </div>
      </div>

      <!-- Sezione Dischi -->
      <div id="dischi" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">
            Quali sono le componenti principali e i tempi caratteristici degli
            HDD?
          </div>
          <div class="answer">
            Piatti rotanti, testine mobili. Tempo di posizionamento = seek +
            latenza rotazionale. Transfer rate lento (~1 Gbit/s). Access latency
            = tempo medio di accesso. Rischio di head crash.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona lo scheduler di deadline in Linux per evitare la
            starvation?
          </div>
          <div class="answer">
            Mantiene code separate per lettura e scrittura, assegna priorità
            alla lettura e gestisce richieste in batch. Usa 4 code: 2 LBA (tipo
            C-SCAN) e 2 FCFS, selezionando la più vecchia se supera i 500ms.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali algoritmi di scheduling disco sono disponibili in RHEL 7?
          </div>
          <div class="answer">
            CFQ (equità tra processi), NOOP (coda FIFO, nessun riordinamento,
            utile per SSD con controller autonomo).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché gli SSD preferiscono accessi casuali e NOOP?
          </div>
          <div class="answer">
            Non hanno testine meccaniche, quindi il seek non incide. Accessi
            casuali sono più efficienti e NOOP evita riordinamenti inutili.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è il fenomeno della write amplification negli SSD?
          </div>
          <div class="answer">
            È l'effetto per cui una singola scrittura può causare molte
            letture/scritture a causa della garbage collection, rallentando le
            prestazioni.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali tecniche si usano per rilevare e correggere errori nei dischi?
          </div>
          <div class="answer">
            Bit di parità, checksum, CRC (Cyclic Redundancy Check), ECC (Error
            Correction Code).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra errori "soft" e "hard" nei dischi?
          </div>
          <div class="answer">
            Soft: temporanei e correggibili. Hard: fisici e permanenti, possono
            essere rilevati ma non sempre corretti.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In cosa consiste la formattazione di un disco?
          </div>
          <div class="answer">
            Formattazione fisica (creazione settori con ECC) e logica (creazione
            file system, strutture dati, cluster).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa succede durante il montaggio (mount) di una partizione?
          </div>
          <div class="answer">
            Il sistema verifica il file system e, se corretto, lo aggancia al
            sistema operativo. La root viene montata all’avvio.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il boot block e qual è il suo ruolo?</div>
          <div class="answer">
            Contiene il bootstrap loader, il codice che carica il kernel in RAM.
            Nei sistemi multi-boot può essere un boot manager.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l’accesso raw e perché è utile?</div>
          <div class="answer">
            È l’accesso diretto al disco senza passare dal file system, usato ad
            esempio dai database per maggiore efficienza.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il ruolo dello spazio di swap?</div>
          <div class="answer">
            Estende la RAM sul disco, usato per swapping e paging. Può risiedere
            su partizioni raw o file. Linux usa bitmap o tabelle per gestirlo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le tre architetture principali di collegamento dello
            storage?
          </div>
          <div class="answer">
            Host-attached (es. SATA, USB), NAS (file system remoto via rete),
            SAN (accesso a blocchi via rete, es. Fibre Channel, iSCSI).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è un RAID e quali sono i suoi obiettivi?
          </div>
          <div class="answer">
            È un insieme di dischi per aumentare affidabilità, prestazioni e
            disponibilità continua attraverso ridondanza e accesso parallelo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le principali metriche di affidabilità nei sistemi RAID?
          </div>
          <div class="answer">
            MTTF (tempo medio al guasto), MTTR (tempo di riparazione), MTTDL
            (tempo medio alla perdita dati irreversibile).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché la NVRAM viene usata nei sistemi RAID?
          </div>
          <div class="answer">
            Agisce da buffer veloce e sicuro per scritture. I dati non si
            perdono in caso di interruzione di corrente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa caratterizza RAID 0 (striping)?</div>
          <div class="answer">
            Distribuisce i dati in blocchi su più dischi. Migliora le
            prestazioni ma non offre ridondanza. Il guasto di un solo disco
            causa la perdita totale dei dati.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa caratterizza RAID 1 (mirroring)?</div>
          <div class="answer">
            Ogni disco ha un duplicato esatto. Fornisce alta affidabilità, ma
            dimezza la capacità effettiva.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa caratterizza RAID 4?</div>
          <div class="answer">
            Usa striping con un disco di parità dedicato. Buono per letture
            sequenziali, ma inefficiente per scritture casuali.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa caratterizza RAID 5?</div>
          <div class="answer">
            Usa striping con parità distribuita. Buon compromesso tra spazio,
            prestazioni e affidabilità. Tollera il guasto di un disco.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa caratterizza RAID 6?</div>
          <div class="answer">
            Come RAID 5, ma con doppia parità. Tollera il guasto di due dischi
            contemporaneamente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa caratterizza RAID 0+1 e RAID 1+0 (RAID 10)?
          </div>
          <div class="answer">
            Combinano mirroring e striping. Offrono alte prestazioni e
            ridondanza, richiedono almeno quattro dischi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa sono i dischi hot spare nei RAID?</div>
          <div class="answer">
            Dischi inattivi pronti a sostituire automaticamente un disco guasto,
            riducendo il tempo di riparazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è uno snapshot nel contesto RAID?</div>
          <div class="answer">
            Un'immagine istantanea del file system, utile per backup o rollback.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la replication nei RAID?</div>
          <div class="answer">
            Copia automatica dei dati su un altro array o sito. Può essere
            sincrona o asincrona.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il thin provisioning?</div>
          <div class="answer">
            Allocazione dinamica dello spazio su disco in base all’uso reale.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos’è l’indirizzamento LBA?</div>
          <div class="answer">
            L’LBA (Logical Block Addressing) mappa ogni blocco logico a una
            posizione fisica. Il settore 0 è nella traccia più esterna del
            cilindro esterno.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i vantaggi e svantaggi delle SSD rispetto agli HDD?
          </div>
          <div class="answer">
            Pro: accesso rapido, affidabilità, silenziosità. Contro: capacità
            inferiore, usura limitata delle celle (max ~100.000 cicli), no
            sovrascrittura diretta.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali algoritmi migliorano l’efficienza e la durata delle SSD?
          </div>
          <div class="answer">
            FTL: mappa logica dei blocchi. Garbage collection: recupera spazio.
            Wear leveling: distribuisce l’usura.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un RAM Disk e quando si usa?</div>
          <div class="answer">
            È una porzione di DRAM usata come disco ad alta velocità, utile per
            elaborazioni temporanee ad alte prestazioni.
          </div>
        </div>
        <div class="card">
          <div class="question">Perché si usano ancora i nastri magnetici?</div>
          <div class="answer">
            Per backup e archiviazione a lungo termine: sono economici e
            capienti, ma lenti.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è lo scopo degli algoritmi di disk scheduling?
          </div>
          <div class="answer">
            Minimizzare il tempo di seek e massimizzare la larghezza di banda
            del disco.
          </div>
        </div>
        <div class="card">
          <div class="question">Pro e contro dell’algoritmo FCFS?</div>
          <div class="answer">
            Pro: semplice, nessuna starvation. Contro: inefficiente in termini
            di seek.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il rischio principale con SSTF?</div>
          <div class="answer">
            Starvation per le richieste lontane, anche se minimizza i singoli
            tempi di seek.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona l’algoritmo SCAN?</div>
          <div class="answer">
            La testina serve richieste in una direzione fino a un’estremità, poi
            inverte. Evita starvation.
          </div>
        </div>
        <div class="card">
          <div class="question">Come differisce C-SCAN da SCAN?</div>
          <div class="answer">
            Dopo aver raggiunto un'estremità, la testina torna all’inizio senza
            servire richieste. Offre tempi di attesa più uniformi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un HDD e come funziona?</div>
          <div class="answer">
            Un HDD è composto da dischi magnetici rotanti. I dati vengono
            registrati e letti tramite un pattern magnetico sulla superficie dei
            dischi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un cilindro in un HDD?</div>
          <div class="answer">
            È un insieme di tracce allineate su tutte le piastre.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le componenti del tempo di accesso di un HDD?
          </div>
          <div class="answer">
            Seek time (tempo per spostare la testa alla traccia giusta) e
            rotational latency (tempo per allineare il settore giusto).
          </div>
        </div>
        <div class="card">
          <div class="question">Come si calcola il Tempo Medio di Accesso?</div>
          <div class="answer">
            Average Access Time = Average Seek Time + Average Rotational Latency
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa include il Tempo Medio di I/O?</div>
          <div class="answer">
            Average Access Time + (Amount to Transfer / Transfer Rate) +
            Controller Overhead.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i vantaggi degli SSD rispetto agli HDD?
          </div>
          <div class="answer">
            Sono più veloci, affidabili, consumano meno energia e non hanno
            parti mobili.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa il Flash Translation Layer (FTL)?</div>
          <div class="answer">
            Mappa i blocchi logici ai fisici e gestisce la garbage collection.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un RAM drive?</div>
          <div class="answer">
            Una porzione di RAM usata come memoria secondaria, estremamente
            veloce, per archiviazione temporanea.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le principali interfacce di connessione dei dischi?
          </div>
          <div class="answer">SATA, NVMe, USB, SCSI.</div>
        </div>
        <div class="card">
          <div class="question">
            Quali algoritmi di disk scheduling conosci?
          </div>
          <div class="answer">FCFS, SCAN, C-SCAN.</div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'algoritmo SCAN?</div>
          <div class="answer">
            Il braccio si muove in una direzione servendo richieste, poi torna
            indietro.
          </div>
        </div>
        <div class="card">
          <div class="question">Quali sono i livelli RAID principali?</div>
          <div class="answer">RAID 0, 1, 4, 5, 6, 0+1, 1+0.</div>
          <div class="card">
            <div class="question">
              Quali algoritmi di disk scheduling conosci?
            </div>
            <div class="answer">FCFS, SCAN, C-SCAN.</div>
          </div>
          <div class="card">
            <div class="question">Cos'è l'algoritmo SCAN?</div>
            <div class="answer">
              Il braccio si muove in una direzione servendo richieste, poi torna
              indietro.
            </div>
          </div>
          <div class="card">
            <div class="question">Quali sono i livelli RAID principali?</div>
            <div class="answer">RAID 0, 1, 4, 5, 6, 0+1, 1+0.</div>
          </div>
          <div class="card">
            <div class="question">Come si calcola l'MTTDL in RAID 1?</div>
            <div class="answer">MTTDL ≈ MTTF² / (2 × MTTR).</div>
          </div>
          <div class="card">
            <div class="question">Cos'è lo striping?</div>
            <div class="answer">
              Distribuzione dei dati su più dischi per migliorare le
              prestazioni.
            </div>
          </div>
          <div class="card">
            <div class="question">Differenze tra RAID 0 e RAID 1?</div>
            <div class="answer">
              RAID 0: striping, prestazioni. RAID 1: mirroring, affidabilità.
            </div>
          </div>
        </div>
        <div class="card">
          <div class="question">Come si calcola l'MTTDL in RAID 1?</div>
          <div class="answer">MTTDL ≈ MTTF² / (2 × MTTR).</div>
        </div>
        <div class="card">
          <div class="question">Cos'è lo striping?</div>
          <div class="answer">
            Distribuzione dei dati su più dischi per migliorare le prestazioni.
          </div>
        </div>
        <div class="card">
          <div class="question">Differenze tra RAID 0 e RAID 1?</div>
          <div class="answer">
            RAID 0: striping, prestazioni. RAID 1: mirroring, affidabilità.
          </div>
        </div>
      </div>

      <!-- Sezione OS161 -->
      <div id="os161" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">Cos'è un mutex lock in OS161?</div>
          <div class="answer">
            Un meccanismo per proteggere sezioni critiche. Usa acquire() e
            release() per garantire mutua esclusione. Può essere implementato
            con spinlock.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è uno spinlock?</div>
          <div class="answer">
            Un lock che attende attivamente (busy waiting) finché non diventa
            disponibile. Efficiente solo per sezioni critiche brevi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un semaforo in OS161?</div>
          <div class="answer">
            Variabile intera con operazioni P (wait) e V (signal), usata per
            sincronizzare thread. Implementa blocco e risveglio dei thread.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona la funzione P() di un semaforo?
          </div>
          <div class="answer">
            Eleva gli interrupt con splhigh(), controlla se valore semaforo è 0,
            se sì blocca il thread con thread_sleep(), altrimenti decrementa e
            continua.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona la funzione V() di un semaforo?
          </div>
          <div class="answer">
            Eleva gli interrupt, incrementa il valore del semaforo e chiama
            thread_wakeup() per sbloccare i thread in attesa.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un lock in OS161?</div>
          <div class="answer">
            Meccanismo per mutua esclusione tra thread. Solo chi ha acquisito un
            lock può rilasciarlo. Basato su semaforo binario.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché si preferiscono i lock ai semafori per sezioni critiche?
          </div>
          <div class="answer">
            Per ownership garantita, maggiore sicurezza, flessibilità e assenza
            di busy waiting con thread_sleep.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è una condition variable (CV)?</div>
          <div class="answer">
            Struttura di sincronizzazione usata con i lock. Offre cv_wait(),
            cv_signal() e cv_broadcast().
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona cv_wait() in OS161?</div>
          <div class="answer">
            Il thread si blocca e rilascia il lock. Al risveglio, riacquisisce
            automaticamente il lock associato.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fanno cv_signal() e cv_broadcast()?</div>
          <div class="answer">
            cv_signal() sveglia un solo thread in attesa. cv_broadcast() sveglia
            tutti i thread in attesa sulla stessa condition variable.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un monitor?</div>
          <div class="answer">
            Un'astrazione per sincronizzazione che include mutua esclusione e
            variabili condition. Solo un processo alla volta può entrare.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le due politiche di scheduling nei monitor?
          </div>
          <div class="answer">
            signal-and-wait (il chiamante si blocca) e signal-and-continue (il
            chiamante continua, il risvegliato aspetta).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un wait channel (wchan) in OS161?</div>
          <div class="answer">
            Strumento del kernel per bloccare e risvegliare thread. Basato su
            spinlock. Funzioni: wchan_sleep() e wchan_wakeone().
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa wchan_sleep()?</div>
          <div class="answer">
            Sospende il thread con thread_switch(), rilascia lo spinlock, e lo
            riacquisisce al risveglio.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa wchan_wakeone()?</div>
          <div class="answer">
            Risveglia un singolo thread bloccato su un wait channel e lo rende
            runnable.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il compito della funzione mips_trap in OS161?
          </div>
          <div class="answer">
            Gestisce eccezioni, interrupt e chiamate di sistema. Legge il codice
            del motivo dal trapframe e chiama il gestore appropriato.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa syscall() in OS161?</div>
          <div class="answer">
            Gestisce le chiamate di sistema: legge il numero di syscall da v0,
            esegue la funzione appropriata, gestisce retval/err, aggiorna epc
            per evitare ripetizione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa succede se la TLB MIPS non trova una corrispondenza?
          </div>
          <div class="answer">
            Solleva una page fault exception. OS161 gestisce l’errore con
            vm_fault, che carica una voce TLB per la pagina richiesta.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il compito della funzione vm_fault() in dumbvm?
          </div>
          <div class="answer">
            Gestisce l’eccezione da page fault. Crea una voce TLB con i dati
            corretti dallo spazio di indirizzamento e la carica.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa execv() in OS161?</div>
          <div class="answer">
            Rimpiazza lo spazio di indirizzamento di un processo con uno nuovo e
            carica un file ELF da eseguire, configurando anche gli argomenti.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un file ELF?</div>
          <div class="answer">
            Contiene segmenti con codice e dati. Specifica dove caricare il
            codice nello spazio degli indirizzi virtuali e l'indirizzo iniziale
            d'esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa rappresenta il problema della sezione critica?
          </div>
          <div class="answer">
            È il problema di garantire che solo un processo per volta acceda a
            una sezione di codice che usa risorse condivise.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le tre condizioni fondamentali per risolvere la sezione
            critica?
          </div>
          <div class="answer">
            Mutua esclusione, progresso e attesa limitata (bounded waiting).
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa l'istruzione test_and_set?</div>
          <div class="answer">
            Imposta un lock a true e restituisce il valore precedente. È
            atomica, usata per acquisire lock evitando race condition.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa compare_and_swap (CAS)?</div>
          <div class="answer">
            Confronta il valore corrente con uno atteso e, se coincide, lo
            sostituisce con uno nuovo. Altrimenti non fa nulla. Ritorna il
            valore letto.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa getppages in OS161?</div>
          <div class="answer">
            Alloca pagine fisiche. Cerca prima tra le pagine libere nella bitmap
            e, se non ne trova, chiama ram_stealmem per ottenere memoria
            contigua.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa getfreeppages?</div>
          <div class="answer">
            Cerca un blocco contiguo di pagine libere nella bitmap per
            l'allocazione di memoria fisica.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa freeppages?</div>
          <div class="answer">
            Marca le pagine come libere nella bitmap, permettendone il
            riutilizzo futuro.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa consente il paging nello user space in OS161?
          </div>
          <div class="answer">
            Permette l'allocazione non contigua della memoria utente,
            migliorando la gestione della memoria e supportando spazi di
            indirizzamento virtuali più grandi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo dei registri MIPS in OS161?
          </div>
          <div class="answer">
            Vengono utilizzati per memorizzare dati e indirizzi durante
            l'esecuzione. Alcuni sono temporanei, altri devono essere
            salvati/ripristinati durante il context switch.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Dove avviene il salvataggio/ripristino dei registri MIPS in OS161?
          </div>
          <div class="answer">
            Nel file switch.S, durante il dispatching tra thread.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la struttura 'proc' in OS161?</div>
          <div class="answer">
            Rappresenta un processo. Contiene nome, numero di thread, spazio di
            indirizzamento e directory di lavoro.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Ogni thread ha uno stack utente e uno kernel?
          </div>
          <div class="answer">
            Sì. Ogni thread ha uno stack per l'esecuzione utente e uno per
            l'esecuzione kernel, per protezione e gestione separata.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il ruolo di runprogram()?</div>
          <div class="answer">
            Avvia un processo utente: apre il file, crea lo spazio
            d'indirizzamento, carica l'eseguibile, prepara lo stack, entra in
            user mode.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa enter_new_process()?</div>
          <div class="answer">
            È l'ultima funzione eseguita dal kernel prima di passare il
            controllo all’eseguibile utente. Imposta il contesto iniziale e
            invoca mips_usermode().
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un processo in OS161?</div>
          <div class="answer">
            Un processo è un programma in esecuzione. Include codice (text),
            stato (program counter, registri), stack (parametri e variabili
            locali), sezione dati (variabili globali) e heap (memoria dinamica).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra programma e processo?
          </div>
          <div class="answer">
            Il programma è un'entità passiva (file su disco), il processo è
            attivo (programma in esecuzione in memoria).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un thread in OS161?</div>
          <div class="answer">
            Un thread è un'unità di esecuzione di un processo, con il proprio
            contesto (PC, SP, registri), stack privato, ma condivide codice e
            dati con altri thread del processo.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è la struttura 'thread' in OS161?</div>
          <div class="answer">
            È una struttura dati che rappresenta un thread kernel. Contiene
            nome, stato, stack, contesto dei registri, CPU assegnata, e
            riferimento al processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            A cosa serve la funzione thread_fork in OS161?
          </div>
          <div class="answer">
            Crea un nuovo thread kernel, specificando nome, processo, funzione
            di entrypoint e dati. Lo rende schedulabile inserendolo nella
            runqueue.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_exit in OS161?</div>
          <div class="answer">
            Termina il thread corrente, rimuovendolo dal sistema. Libera
            risorse, disabilita interruzioni e invoca lo scheduler per un
            context switch.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è lo scopo di thread_yield?</div>
          <div class="answer">
            Permette al thread corrente di cedere volontariamente la CPU pur
            rimanendo eseguibile. Viene reinserito nella runqueue.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_switch?</div>
          <div class="answer">
            Esegue il context switch: salva il contesto del thread corrente e
            passa al successivo dalla runqueue della CPU.
          </div>
        </div>
        <div class="card">
          <div class="question">Che ruolo ha getppages in OS161?</div>
          <div class="answer">
            Alloca pagine fisiche (multipli di 4 KB) chiamando ram_stealmem, con
            protezione tramite lock per ambienti multithreaded.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa ram_stealmem?</div>
          <div class="answer">
            Alloca memoria fisica contigua a partire da firstpaddr. Usata nella
            fase iniziale del kernel prima che la VM sia attiva.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è OS161?</div>
          <div class="answer">
            Un sistema operativo didattico che gira su architettura MIPS
            simulata. È progettato per essere semplice e comprensibile.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il comportamento di un processo quando termina in OS161 e
            cosa succede se nessuno chiama waitpid() su di esso?
          </div>
          <div class="answer">
            Il processo entra in uno stato "zombie" e la sua struttura dati
            struct proc resta in memoria finché un altro processo non recupera
            il suo stato di uscita tramite waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quale funzione viene utilizzata per creare un nuovo processo tramite
            proc_create_runprogram()?
          </div>
          <div class="answer">
            La funzione crea il processo e lo avvia, salvando il suo pid, ad
            esempio in proc→p_pid, e possibilmente utilizzando sys_getpid(proc)
            per recuperarne il pid.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando un processo termina e un altro processo chiama sys_waitpid(),
            cosa succede?
          </div>
          <div class="answer">
            La funzione cerca il processo corrispondente nella tabella, chiama
            proc_wait() passando il processo, attende la sua terminazione,
            libera la struct proc e ritorna il codice di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è l’obiettivo di proc_wait() in relazione alla funzione
            sys_waitpid()?
          </div>
          <div class="answer">
            proc_wait() viene chiamata internamente da sys_waitpid() ed è
            responsabile di attendere la terminazione del processo, di liberare
            la sua struttura dati e di fornire il codice di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si garantisce la corretta gestione dei processi zombie in
            OS161?
          </div>
          <div class="answer">
            Attraverso l’uso di waitpid(), che permette a un processo di
            aspettare la terminazione del processo figlio, recuperarne lo stato
            e liberare le risorse assegnate, evitando che rimangano in memoria
            in stato zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché è importante implementare correttamente waitpid() nel sistema
            operativo?
          </div>
          <div class="answer">
            Per permettere la sincronizzazione tra processi nel loro ciclo di
            vita e per liberare correttamente le risorse, prevenendo perdite di
            memoria o processi zombie inutilmente in memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che ruolo gioca sys_getpid() nel contesto dei processi?
          </div>
          <div class="answer">
            sys_getpid() permette di ottenere il pid del processo corrente,
            utile per identificare e gestire i processi in tutte le operazioni
            di sistema.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i passi principali coinvolti nella terminazione di un
            processo e nell’attesa di un processo figlio?
          </div>
          <div class="answer">
            Creazione del processo con proc_create_runprogram(), terminazione
            del processo, gestione di processi zombie, chiamata a waitpid() per
            recuperare lo stato di uscita e liberare le risorse.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di proc_end_waitpid() nel ciclo di gestione dei
            processi in OS161?
          </div>
          <div class="answer">
            Rimuove un processo dalla tabella dei processi, dealloca le
            strutture di sincronizzazione associate a waitpid() come semafori,
            condition variable, e lock, e libera le risorse di memoria usate dal
            processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene assegnato un PID univoco in OS161?
          </div>
          <div class="answer">
            Durante l'inizializzazione, proc_init_waitpid() cerca un indice
            libero nella tabella dei processi, lo assegna a p_pid e lo inserisce
            nella tabella, garantendo unicità finché ci sono slot disponibili.
          </div>
        </div>
        <div class="card">
          <div class="question">Che funzione svolge proc_init_waitpid()?</div>
          <div class="answer">
            Assegna un PID univoco a un nuovo processo, inserisce il processo
            nella tabella globale, e inizializza le strutture di
            sincronizzazione come semafori o condition variable per waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché viene preferibile delegare la distruzione di un processo a
            proc_wait() invece che a sys__exit()?
          </div>
          <div class="answer">
            Per evitare che il processo rimanga zombie; proc_wait() attende la
            terminazione, recupera lo stato di uscita e distrugge correttamente
            la struttura, assicurando che il padre possa recuperare lo stato
            senza problemi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali campi sono fondamentali in struct proc per la gestione di
            waitpid() e perché?
          </div>
          <div class="answer">
            p_status salva lo stato di uscita, p_pid identifica il processo
            univocamente, e le strutture di sincronizzazione (p_sem o p_cv e
            p_lock) sono usate per sincronizzare il padre con il termine del
            figlio.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa succede quando un processo chiama exit() in OS161?
          </div>
          <div class="answer">
            Cambia lo stato a terminato, imposta p_status, risveglia il padre
            tramite V(p_sem) o cv_signal(), ma la struttura proc resta fino a
            quando waitpid() non la libera, per evitare processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In cosa consiste l'implementazione di proc_end_waitpid()?
          </div>
          <div class="answer">
            Rimuove il processo dalla tabella, dealloca i semafori o condition
            variable e lock associati, e libera la risorsa di memoria,
            garantendo la corretta gestione delle risorse dei processi
            terminati.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di proc_wait() nel gestire la terminazione di un
            processo in OS161?
          </div>
          <div class="answer">
            proc_wait() blocca il processo padre finché il processo figlio non
            termina, recupera lo stato di uscita (p_status), e libera le risorse
            associate alla struttura proc, garantendo una gestione corretta del
            ciclo di vita del processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene sincronizzata la terminazione del processo tra exit() e
            waitpid()?
          </div>
          <div class="answer">
            exit() aggiorna p_status e risveglia il padre con V(p_sem) o
            cv_signal(), mentre waitpid() si blocca attendendo questa notifica,
            poi recupera p_status e libera la struttura proc.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che funzione ha la variabile return_status in proc_wait()?
          </div>
          <div class="answer">
            Memorizza il valore di p_status del processo terminato, che sarà
            restituito come risultato della chiamata proc_wait().
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il comportamento di proc_destroy()?</div>
          <div class="answer">
            Libera tutte le risorse associate al processo, incluse le strutture
            di sincronizzazione (semaphori, CV, lock) e la memoria allocata, e
            rimuove il processo dalla tabella globale prontamente usata dal
            sistema.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché la rimozione di un processo termina a proc_destroy() e non
            immediatamente in exit()?
          </div>
          <div class="answer">
            Per garantire che il processo padre abbia il tempo di recuperare lo
            stato di uscita prima che le risorse vengano deallocate, evitando
            così processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come avviene il recupero della risorsa p_sem o p_cv in
            proc_end_waitpid()?
          </div>
          <div class="answer">
            Viene deallocata tramite sem_destroy() o cv_destroy() e
            lock_destroy(), rispettivamente, per liberare le risorse di
            sincronizzazione associate al processo terminato.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è l'importanza di mantenere p_status aggiornato?
          </div>
          <div class="answer">
            Permette al processo padre di conoscere lo stato di uscita del
            processo figlio, utile in waitpid() per decidere il comportamento
            successivo e per gestire l'esito della terminazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa sono paddr_t e vaddr_t?</div>
          <div class="answer">
            paddr_t è un indirizzo fisico in RAM; vaddr_t è un indirizzo
            virtuale usato da processi o kernel.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come avviene il debugging del kernel OS161?
          </div>
          <div class="answer">
            Con sys161 -w kernel in ascolto e mips-harvard-os161-gdb su un
            secondo terminale.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_fork in OS161?</div>
          <div class="answer">
            Crea un nuovo thread specificando nome, processo padre e funzione da
            eseguire.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che struttura rappresenta un processo in OS161?
          </div>
          <div class="answer">
            La struct proc, contenente nome, lock, numero thread, addrspace,
            cwd, e info waitpid.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la struct addrspace?</div>
          <div class="answer">
            Rappresenta lo spazio di indirizzamento virtuale di un processo.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona DumbVM?</div>
          <div class="answer">
            Traduce vaddr in paddr usando segmenti fissi per codice, dati e
            stack, con allocazione contigua.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve ram_stealmem?</div>
          <div class="answer">
            Alloca pagine fisiche in modo contiguo direttamente dalla RAM.
          </div>
        </div>
        <div class="card">
          <div class="question">Che ruolo ha la funzione getppages?</div>
          <div class="answer">
            Interfaccia di allocazione memoria che usa getfreeppages o
            ram_stealmem.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene gestita la deallocazione della memoria?
          </div>
          <div class="answer">
            Con freeppages, che segna le pagine come libere in freeRamFrames.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona la syscall write?</div>
          <div class="answer">
            Scrive dati su stdout/stderr leggendo byte da un buffer utente.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona la syscall read?</div>
          <div class="answer">
            Legge dati da stdin, byte per byte, memorizzandoli in un buffer.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è una syscall e come viene gestita in OS161?
          </div>
          <div class="answer">
            È un'interfaccia per servizi del kernel, gestita da syscall() che
            usa un trapframe.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona waitpid?</div>
          <div class="answer">
            Permette a un processo padre di attendere la terminazione del figlio
            e recuperarne lo stato.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che struttura tiene traccia dei processi in OS161?
          </div>
          <div class="answer">
            La tabella processTable, che associa PID a struct proc.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa sono race condition, deadlock e starvation?
          </div>
          <div class="answer">
            Problemi della concorrenza dovuti all'ordine di esecuzione e
            gestione delle risorse.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la soluzione di Peterson?</div>
          <div class="answer">
            Un algoritmo software per mutua esclusione tra due processi.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa compare_and_swap?</div>
          <div class="answer">
            Aggiorna una variabile solo se ha il valore atteso, garantendo
            atomicità.
          </div>
        </div>
        <div class="card">
          <div class="question">Che differenza c'è tra lock e semaforo?</div>
          <div class="answer">
            Il lock ha ownership, può essere rilasciato solo dal proprietario;
            il semaforo no.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è una condition variable?</div>
          <div class="answer">
            Meccanismo di sincronizzazione che consente a un thread di attendere
            una condizione.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona cv_wait?</div>
          <div class="answer">
            Il thread rilascia il lock, va in attesa e lo riacquisisce al
            risveglio.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è una wait channel?</div>
          <div class="answer">
            Struttura kernel per mettere in attesa i thread in modo efficiente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa la funzione proc_wait?</div>
          <div class="answer">
            Attende la terminazione del processo figlio e ne recupera lo stato.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona la system call exit?</div>
          <div class="answer">
            Libera l'addrspace, notifica il padre e termina il thread con
            thread_exit.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra proc_wait e sys_waitpid?
          </div>
          <div class="answer">
            proc_wait lavora con puntatori a proc, sys_waitpid lavora con PID.
          </div>
        </div>
        <div class="card">
          <div class="question">Come si implementano lock in OS161?</div>
          <div class="answer">
            Con semaforo binario o con wait channel e spinlock, a seconda
            dell'opzione.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona il test tt1?</div>
          <div class="answer">
            Crea 8 thread che stampano caratteri; verifica la gestione dei
            thread.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il comportamento di un processo quando termina in OS161 e
            cosa succede se nessuno chiama waitpid() su di esso?
          </div>
          <div class="answer">
            Il processo entra in uno stato "zombie" e la sua struttura dati
            struct proc resta in memoria finché un altro processo non recupera
            il suo stato di uscita tramite waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quale funzione viene utilizzata per creare un nuovo processo tramite
            proc_create_runprogram()?
          </div>
          <div class="answer">
            La funzione crea il processo e lo avvia, salvando il suo pid, ad
            esempio in proc→p_pid, e possibilmente utilizzando sys_getpid(proc)
            per recuperarne il pid.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando un processo termina e un altro processo chiama sys_waitpid(),
            cosa succede?
          </div>
          <div class="answer">
            La funzione cerca il processo corrispondente nella tabella, chiama
            proc_wait() passando il processo, attende la sua terminazione,
            libera la struct proc e ritorna il codice di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è l'obiettivo di proc_wait() in relazione alla funzione
            sys_waitpid()?
          </div>
          <div class="answer">
            proc_wait() viene chiamata internamente da sys_waitpid() ed è
            responsabile di attendere la terminazione del processo, di liberare
            la sua struttura dati e di fornire il codice di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si garantisce la corretta gestione dei processi zombie in
            OS161?
          </div>
          <div class="answer">
            Attraverso l'uso di waitpid(), che permette a un processo di
            aspettare la terminazione del processo figlio, recuperarne lo stato
            e liberare le risorse assegnate, evitando che rimangano in memoria
            in stato zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché è importante implementare correttamente waitpid() nel sistema
            operativo?
          </div>
          <div class="answer">
            Per permettere la sincronizzazione tra processi nel loro ciclo di
            vita e per liberare correttamente le risorse, prevenendo perdite di
            memoria o processi zombie inutilmente in memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che ruolo gioca sys_getpid() nel contesto dei processi?
          </div>
          <div class="answer">
            sys_getpid() permette di ottenere il pid del processo corrente,
            utile per identificare e gestire i processi in tutte le operazioni
            di sistema.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i passi principali coinvolti nella terminazione di un
            processo e nell'attesa di un processo figlio?
          </div>
          <div class="answer">
            Creazione del processo con proc_create_runprogram(), terminazione
            del processo, gestione di processi zombie, chiamata a waitpid() per
            recuperare lo stato di uscita e liberare le risorse.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di proc_end_waitpid() nel ciclo di gestione dei
            processi in OS161?
          </div>
          <div class="answer">
            Rimuove un processo dalla tabella dei processi, dealloca le
            strutture di sincronizzazione associate a waitpid() come semafori,
            condition variable, e lock, e libera le risorse di memoria usate dal
            processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene assegnato un PID univoco in OS161?
          </div>
          <div class="answer">
            Durante l'inizializzazione, proc_init_waitpid() cerca un indice
            libero nella tabella dei processi, lo assegna a p_pid e lo inserisce
            nella tabella, garantendo unicità finché ci sono slot disponibili.
          </div>
        </div>
        <div class="card">
          <div class="question">Che funzione svolge proc_init_waitpid()?</div>
          <div class="answer">
            Assegna un PID univoco a un nuovo processo, inserisce il processo
            nella tabella globale, e inizializza le strutture di
            sincronizzazione come semafori o condition variable per waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché viene preferibile delegare la distruzione di un processo a
            proc_wait() invece che a sys__exit()?
          </div>
          <div class="answer">
            Per evitare che il processo rimanga zombie; proc_wait() attende la
            terminazione, recupera lo stato di uscita e distrugge correttamente
            la struttura, assicurando che il padre possa recuperare lo stato
            senza problemi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali campi sono fondamentali in struct proc per la gestione di
            waitpid() e perché?
          </div>
          <div class="answer">
            p_status salva lo stato di uscita, p_pid identifica il processo
            univocamente, e le strutture di sincronizzazione (p_sem o p_cv e
            p_lock) sono usate per sincronizzare il padre con il termine del
            figlio.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa succede quando un processo chiama exit() in OS161?
          </div>
          <div class="answer">
            Cambia lo stato a terminato, imposta p_status, risveglia il padre
            tramite V(p_sem) o cv_signal(), ma la struttura proc resta fino a
            quando waitpid() non la libera, per evitare processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In cosa consiste l'implementazione di proc_end_waitpid()?
          </div>
          <div class="answer">
            Rimuove il processo dalla tabella, dealloca i semafori o condition
            variable e lock associati, e libera la risorsa di memoria,
            garantendo la corretta gestione delle risorse dei processi
            terminati.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i campi principali della struttura proc per la gestione
            del ciclo di vita dei processi in OS161?
          </div>
          <div class="answer">
            I campi principali sono p_status, p_pid, p_name, p_lock, p_cv o
            p_sem, p_addrspace, p_cwd, oltre a contatori di thread e altre
            strutture di sistema.
          </div>
        </div>
        <div class="card">
          <div class="question">
            A cosa serve il campo p_status nella struttura proc?
          </div>
          <div class="answer">
            p_status salva lo stato di uscita del processo ed è utilizzato dalla
            funzione waitpid() per determinare se un processo è terminato.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene identificato univocamente un processo in OS161?
          </div>
          <div class="answer">
            Attraverso il campo p_pid, che assegna un identificatore univoco a
            ogni processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è lo scopo di un meccanismo di sincronizzazione come semafori o
            variabili di condizione?
          </div>
          <div class="answer">
            Permette al processo padre di attendere la terminazione del processo
            figlio, garantendo una gestione corretta delle operazioni di exit()
            e waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quando p_status viene inizializzato e perché?
          </div>
          <div class="answer">
            p_status viene inizializzato a 0 per indicare che il processo non ha
            ancora terminato o segnalato il suo stato di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali strutture di sincronizzazione vengono usate nelle
            implementazioni di waitpid()?
          </div>
          <div class="answer">
            Si possono usare semafori (p_sem) o variabili di condizione (p_cv) e
            lock (p_lock), a seconda della configurazione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene assegnato un PID ai processi durante l'inizializzazione
            in OS161?
          </div>
          <div class="answer">
            Utilizzando una strategia circolare in una tabella di processi,
            tramite la funzione proc_init_waitpid(), che assegna un PID libero e
            lo registra nella tabella.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In cosa consiste la funzione common_prog() presente in questa
            versione di sys_waitpid()?
          </div>
          <div class="answer">
            Crea un processo, avvia un thread per eseguire il programma, quindi
            ottiene il PID del processo figlio e attende la sua terminazione
            tramite sys_waitpid(pid).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo della tabella globale dei processi in sys_waitpid()?
          </div>
          <div class="answer">
            Tiene traccia di tutti i processi e permette di effettuare l'attesa
            e il recupero dello stato di uscita attraverso i PID, poiché i
            kernel o processi utente non accedono direttamente a proc.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché nel kernel OS161 bisogna usare KASSERT()?
          </div>
          <div class="answer">
            Per verificare che le condizioni critiche siano vere durante
            l'esecuzione; se false, il sistema effettua un panico per prevenire
            danni seri come sovrascrizioni di memoria o comportamento
            imprevedibile.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è l’obiettivo principale di proc_init_waitpid() in OS161?
          </div>
          <div class="answer">
            Inizializza i campi di un processo, in particolare p_pid, p_status,
            e le strutture di sincronizzazione (p_sem o p_cv e p_lock), per
            consentire la gestione della terminazione e dell’attesa tramite
            waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona proc_init_waitpid() per assegnare un PID a un nuovo
            processo?
          </div>
          <div class="answer">
            Cerca un indice libero nella tabella dei processi usando una
            strategia circolare, assegna il processo a quell’indice, e imposta
            p_pid di conseguenza. Se la tabella è piena, genera un panico.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il valore di p_status all’inizio durante l’inizializzazione
            con proc_init_waitpid()?
          </div>
          <div class="answer">
            p_status viene impostato a 0, indicando uno stato iniziale di uscita
            ancora non definito.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene creato il semaforo o le variabili di condizione associate
            a un processo in proc_init_waitpid()?
          </div>
          <div class="answer">
            Se si usa USE_SEMAPHORE_FOR_WAITPID, si crea un semaforo con
            sem_create(). Altrimenti, si creano una variabile di condizione
            (cv_create()) e un lock (lock_create()).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è lo scopo di p_sem, p_cv, e p_lock nei processi?
          </div>
          <div class="answer">
            Sono usati per sincronizzare il processo padre con il processo
            figlio durante la terminazione, permettendo al padre di aspettare
            (waitpid()) e di leggere lo stato di uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa succede se la tabella dei processi è piena durante
            proc_init_waitpid()?
          </div>
          <div class="answer">
            Viene chiamato panic() con un messaggio di errore, indicando che il
            sistema ha troppi processi attivi e la tabella è piena.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di p_pid nel sistema di gestione dei processi in
            OS161?
          </div>
          <div class="answer">
            Identifica univocamente un processo nel sistema, permettendo di
            riferirsi ad esso nelle chiamate di sistema come waitpid() e nelle
            tabelle globali.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo della funzione proc_search_pid() in OS161?
          </div>
          <div class="answer">
            Restituisce il puntatore alla struttura proc associata a un dato
            PID, utile per implementare waitpid() o per cercare figli da parte
            del processo padre.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona proc_search_pid()?</div>
          <div class="answer">
            Controlla che il PID sia valido (tra 1 e MAX_PROC), quindi ritorna
            il puntatore nella tabella processTable.proc[pid], verificando che
            il PID corrisponda.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa rappresenta la struttura _processTable in OS161?
          </div>
          <div class="answer">
            È una tabella globale che tiene traccia di tutti i processi attivi,
            inclusa la lista di puntatori a proc, l’indice dell’ultimo PID
            assegnato (last_i), e un lock (lk) per l’accesso concorrente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è lo scopo di proc_destroy() in OS161?
          </div>
          <div class="answer">
            Dealloca le risorse associate a un processo, come p_sem o p_cv,
            rimuove il processo dalla tabella, e libera la memoria strutturale,
            garantendo che non rimangano processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona proc_end_waitpid()?</div>
          <div class="answer">
            Rimuove il processo dalla tabella dei processi, dealloca le
            strutture di sincronizzazione (p_sem, p_cv, p_lock), e libera le
            risorse usate dal processo, come parte della gestione di
            terminazione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché proc_wait() non distrugge immediatamente il processo?
          </div>
          <div class="answer">
            Per garantire che il padre possa recuperare lo stato di uscita del
            figlio, proc_wait() aspetta che il processo termini, recupera lo
            stato e poi distrugge la struttura proc.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona proc_wait() in OS161?</div>
          <div class="answer">
            Usa un meccanismo di sincronizzazione (semaphore o CV+lock) per
            bloccare il processo padre fino a quando il figlio termina. Quindi
            legge p_status, chiama proc_destroy(), e restituisce lo stato di
            uscita.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa succede quando un processo termina in sys__exit()?
          </div>
          <div class="answer">
            Notifica il termine con thread_exit() ma non distrugge subito la
            struttura proc, lasciando questa operazione a proc_wait() per
            evitare processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come vengono rimosse risorse di sincronizzazione in
            proc_end_waitpid()?
          </div>
          <div class="answer">
            Se si usa un semaforo, si chiama sem_destroy(). Se si usano CV e
            lock, si chiamano cv_destroy() e lock_destroy(). Poi si rimuove il
            processo dalla tabella.
          </div>
        </div>
        <div class="card">
          <div class="question">Che cosa rappresenta p_status in una proc?</div>
          <div class="answer">
            Memorizza lo stato di uscita del processo, impostato da exit() e
            letto da waitpid(); inizialmente a 0, poi aggiornato al termine.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché si utilizza una strategia circolare con last_i in
            proc_init_waitpid()?
          </div>
          <div class="answer">
            Per cercare in modo efficiente una posizione libera nella tabella
            dei processi, ripartendo dall’ultimo assegnato, ottimizzando
            l’allocazione dei PID.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il ruolo di KASSERT() nel sistema?</div>
          <div class="answer">
            È una macro di controllo che verifica condizioni critiche durante
            l’esecuzione. Se una condizione fallisce, blocca il sistema e stampa
            un messaggio di errore, facilitando il debugging.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene garantita la sicurezza delle operazioni sulla tabella dei
            processi?
          </div>
          <div class="answer">
            Utilizzando un spinlock (processTable.lk) per controllare l’accesso
            concorrente e mantenere l’integrità dei dati.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa si intende con “processi zombie” in OS161?
          </div>
          <div class="answer">
            Processi terminati che non sono ancora stati distrutti, ancora
            presenti nella tabella dei processi, perché il padre non ha chiamato
            waitpid() per recuperare lo stato.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il comportamento di proc_destroy() in relazione a waitpid()?
          </div>
          <div class="answer">
            proc_destroy() viene chiamato da proc_wait() dopo aver recuperato lo
            stato di uscita, garantendo che il processo sia correttamente
            eliminato dalla tabella e tutte le risorse siano deallocate.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è lo scopo principale di proc_init_waitpid()?
          </div>
          <div class="answer">
            Assegnare un PID unico, registrare il processo nella tabella
            globale, e inizializzare le primitive di sincronizzazione (p_sem o
            p_cv e p_lock) per supportare waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come vengono allocate le risorse di sincronizzazione in
            proc_init_waitpid()?
          </div>
          <div class="answer">
            Se si utilizza un semaforo, si crea con sem_create(). Se si
            utilizzano CV e lock, si creano con cv_create() e lock_create()
            rispettivamente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di p_pid all’interno della struttura proc?
          </div>
          <div class="answer">
            Identifica in modo univoco il processo nel sistema, assegnato da
            proc_init_waitpid() e usato per cercare processi specifici.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa la funzione proc_end_waitpid()?</div>
          <div class="answer">
            Rimuove un processo dalla tabella, dealloca le primitive di
            sincronizzazione, e libera le risorse associate a waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene gestita la rimozione di un processo dalla tabella in
            proc_end_waitpid()?
          </div>
          <div class="answer">
            Acquisisce il lock sulla tabella, azzera l’entry corrispondente a
            p_pid, poi dealloca p_sem o p_cv e p_lock secondo l’opzione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa rappresenta p_status in struct proc?
          </div>
          <div class="answer">
            Lo stato di uscita del processo, vengono impostati da exit() e letti
            da waitpid(), inizialmente a 0.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il ruolo di proc_destroy() nel ciclo di vita di un processo?
          </div>
          <div class="answer">
            Dealloca le risorse della struttura proc, rimuove il processo dalla
            tabella e libera la memoria, mantenendo il sistema pulito da
            processi zombie.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si assegna un nuovo p_pid in proc_init_waitpid()?
          </div>
          <div class="answer">
            Si cerca un indice libero nella tabella usando un’operazione
            circolare partendo da last_i+1 e, una volta trovato, si assegna
            p_pid e si aggiorna last_i.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa succede se la tabella dei processi è piena in
            proc_init_waitpid()?
          </div>
          <div class="answer">
            La funzione panica con il messaggio "troppi processi. proc table is
            full" quando non è possibile assegnare un PID.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è la funzione di proc_search_pid()?</div>
          <div class="answer">
            Cerca e ritorna il puntatore alla struttura proc associata a uno
            specifico PID, facilitando operazioni come waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene garantita la sicurezza durante l’assegnazione dei PID?
          </div>
          <div class="answer">
            Acquisendo il lock processTable.lk prima di modificare la tabella,
            per garantire accesso esclusivo e integrità dei dati.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che cosa succede quando un processo termina e exit() viene chiamato?
          </div>
          <div class="answer">
            Aggiorna p_status con il valore di uscita, avvisa eventualmente il
            padre tramite la primitive di sincronizzazione, ma la distruzione
            del processo avviene tramite waitpid().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché in proc_end_waitpid() si rimuove il processo dalla tabella?
          </div>
          <div class="answer">
            Per evitare riferimenti pendenti e per mantenere aggiornata la
            tabella, consentendo di riutilizzare gli slot liberi per nuovi
            processi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si deallocano le primitive di sincronizzazione in
            proc_end_waitpid()?
          </div>
          <div class="answer">
            Se si usa un semaforo, si chiama sem_destroy(). Se si usa CV e lock,
            si chiamano cv_destroy() e lock_destroy().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la funzione principale del ciclo di vita di proc in relazione
            a waitpid()?
          </div>
          <div class="answer">
            Creare, assegnare PID, sincronizzare con padre, attendere
            terminazione, leggere stato di uscita, e infine deallocare le
            risorse.
          </div>
        </div>
      </div>

      <!-- Sezione I/O -->
      <div id="io" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">
            Quali sono le principali categorie di dispositivi di I/O?
          </div>
          <div class="answer">
            Dispositivi di memorizzazione (dischi, SSD), dispositivi di
            trasmissione (schede di rete), interfacce utente (tastiere, mouse,
            schermi).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il memory-mapped I/O?</div>
          <div class="answer">
            È una tecnica in cui i registri dei dispositivi di I/O sono mappati
            nello spazio di indirizzamento della memoria, rendendoli accessibili
            tramite normali istruzioni di load/store.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona il polling per l'I/O?</div>
          <div class="answer">
            La CPU interroga ripetutamente il registro di stato del dispositivo.
            È semplice ma inefficiente per dispositivi lenti perché causa busy
            waiting.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è un interrupt e come migliora il polling?
          </div>
          <div class="answer">
            Un interrupt è un segnale inviato al processore da un dispositivo
            pronto. La CPU risponde eseguendo una routine di servizio, evitando
            l’attesa attiva del polling.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa il controller DMA?</div>
          <div class="answer">
            Permette ai dispositivi di trasferire dati direttamente in memoria
            senza coinvolgere la CPU. Migliora le prestazioni usando il bus
            mastering e riduce il carico sulla CPU.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il ruolo del device driver?</div>
          <div class="answer">
            È un modulo software che fornisce un'interfaccia standard al kernel,
            nascondendo le peculiarità hardware dei dispositivi e implementando
            le system call di I/O.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la differenza tra dispositivi a blocchi e a caratteri?
          </div>
          <div class="answer">
            A blocchi (dischi): accesso a blocchi di dati con DMA. A caratteri
            (tastiere): accesso byte per byte con funzioni come get() e put().
          </div>
        </div>
        <div class="card">
          <div class="question">
            Che differenza c’è tra I/O bloccante, non bloccante e asincrono?
          </div>
          <div class="answer">
            Bloccante: il processo aspetta. Non bloccante: continua l’esecuzione
            e verifica lo stato. Asincrono: una callback o evento segnala la
            fine dell’I/O.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'I/O vettorizzato?</div>
          <div class="answer">
            Permette di effettuare più operazioni di I/O con una sola system
            call. Riduce il numero di chiamate, migliora performance e può
            offrire atomicità.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa il buffering nell'I/O?</div>
          <div class="answer">
            Utilizza aree di memoria tampone per gestire differenze di velocità
            e dimensioni tra dispositivi. Permette doppio buffering per
            efficienza e coerenza.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'allocazione a lista concatenata?</div>
          <div class="answer">
            Ogni file è memorizzato in blocchi non contigui collegati tra loro.
            Ogni blocco contiene un puntatore al successivo. Vantaggi: elimina
            frammentazione esterna. Svantaggi: accesso diretto lento e fragilità
            in caso di perdita di link.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona la FAT (File Allocation Table)?
          </div>
          <div class="answer">
            È una tabella che tiene traccia della sequenza dei blocchi di un
            file. Migliora fault tolerance e accesso diretto, memorizzata in RAM
            per velocità. Ogni blocco ha un puntatore nella FAT.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'allocazione a indice?</div>
          <div class="answer">
            Ogni file ha un blocco indice che contiene gli indirizzi dei blocchi
            dati. Vantaggi: accesso diretto ed eliminazione frammentazione
            esterna. Svantaggi: limite dimensione file e necessità di livelli
            multipli d’indice per file grandi.
          </div>
        </div>
        <div class="card">
          <div class="question">Come gestisce Unix l'allocazione a indice?</div>
          <div class="answer">
            Usa I-node con indici diretti, indiretti, doppi e tripli. Permette
            scalabilità dei file: pochi livelli per file piccoli, più livelli
            per file grandi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali tecniche esistono per la gestione dello spazio libero?
          </div>
          <div class="answer">
            Bitmap, liste concatenate, grouping, counting. Bitmap è efficiente
            per trovare blocchi; grouping e counting migliorano efficienza della
            lista concatenata.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si ottimizzano le prestazioni del file system?
          </div>
          <div class="answer">
            Tecniche: preallocazione dei metadati, collocazione dati/metadati,
            buffer cache, scritture asincrone, free-behind e read-ahead.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la Page Cache e la Unified Buffer Cache?
          </div>
          <div class="answer">
            Page Cache mappa i blocchi su pagine di memoria (memory-mapped I/O).
            Unified Buffer Cache evita doppio caching unificando page cache e
            buffer cache.
          </div>
        </div>
        <div class="card">
          <div class="question">Come avviene il recovery del file system?</div>
          <div class="answer">
            Attraverso log structured (journal) e backup. I log salvano lo stato
            e le operazioni in corso, permettendo il recupero dopo un crash.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa caratterizza la Directory a due livelli (Two-Level Directory)?
          </div>
          <div class="answer">
            Ogni utente ha una propria directory. La root contiene una directory
            per ogni utente. Risolve i problemi di naming e grouping, ma non
            consente sottogruppi logici all’interno della directory utente.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa caratterizza la Directory ad albero (Tree-Structured
            Directory)?
          </div>
          <div class="answer">
            Struttura gerarchica con directory e sottodirectory. Supporta path
            assoluti e relativi. Utile per organizzazione logica e comandi come
            cd, mkdir, rm.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa caratterizza la Directory a grafo aciclico (Acyclic-Graph
            Directory)?
          </div>
          <div class="answer">
            Permette la condivisione di file o directory tramite link. Gestisce
            aliasing. Richiede soluzioni per evitare dangling pointers come
            backpointers o reference counting.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa caratterizza la Directory a grafo generale (General Graph
            Directory)?
          </div>
          <div class="answer">
            Estensione del grafo aciclico che consente cicli. Il sistema deve
            rilevare i cicli e usare garbage collection o restrizioni per
            evitarli.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa significa montare un file system (Mounting)?
          </div>
          <div class="answer">
            Collega un file system fisico a una directory esistente nel file
            system corrente. Può essere fatto all’avvio o dinamicamente. Un file
            system non montato non è accessibile.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona la condivisione dei file nei sistemi multiutente?
          </div>
          <div class="answer">
            Tramite ID utente e di gruppo, permessi RWX, ACL, e protocolli di
            rete. File e directory hanno proprietario e gruppo. La protezione è
            fondamentale per coerenza e sicurezza.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i permessi di accesso ai file nei sistemi Unix-like?
          </div>
          <div class="answer">
            Read (R), Write (W), Execute (X). Ogni file ha permessi assegnati a
            Owner, Group, Others. Esempio: rw-rw-r-- → Proprietario e gruppo
            possono leggere e scrivere, altri solo leggere.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un ACL (Access Control List)?</div>
          <div class="answer">
            Struttura che specifica permessi granulari per utenti o gruppi.
            Permette di definire eccezioni o regole dettagliate rispetto ai
            permessi standard RWX.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è la gestione I/O nei sistemi operativi?
          </div>
          <div class="answer">
            È la componente che controlla l'interazione tra il sistema e i
            dispositivi I/O, astratta tramite driver.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i componenti hardware principali per l'I/O?
          </div>
          <div class="answer">
            Porta, bus (es. PCIe), e controller (es. HBA).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come comunica la CPU con un controller I/O?
          </div>
          <div class="answer">
            Tramite registri mappati in memoria o porte I/O.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il polling e quando è inefficiente?</div>
          <div class="answer">
            Tecnica in cui la CPU controlla ripetutamente lo stato del
            dispositivo; inefficiente con dispositivi lenti.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa sono gli interrupt e come migliorano l'efficienza?
          </div>
          <div class="answer">
            Segnali hardware che avvisano la CPU quando un dispositivo è pronto,
            evitando il polling continuo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Differenza tra interrupt, eccezioni e trappole?
          </div>
          <div class="answer">
            Interrupt: evento esterno. Eccezione: errore interno. Trappola:
            istruzione software.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il DMA e quale vantaggio offre?</div>
          <div class="answer">
            Permette trasferimento diretto tra memoria e dispositivo senza CPU,
            utile per grandi volumi di dati.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa il kernel per ottimizzare l'I/O?</div>
          <div class="answer">
            Gestisce buffering, caching, spooling, errori e pianificazione I/O.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un file system?</div>
          <div class="answer">
            Sistema che organizza e gestisce file e directory sui dispositivi di
            memorizzazione.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono le operazioni fondamentali sui file?
          </div>
          <div class="answer">
            Creazione, lettura, scrittura, seek, eliminazione, truncamento.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un file lock e quali tipi esistono?</div>
          <div class="answer">
            Meccanismo di blocco per garantire l'accesso esclusivo; può essere
            condiviso o esclusivo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Differenza tra accesso sequenziale e diretto?
          </div>
          <div class="answer">
            Sequenziale: lettura/scrittura ordinata. Diretto: accesso a blocchi
            specifici.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona una directory tree-structured?
          </div>
          <div class="answer">
            Ogni file ha un percorso unico; gli utenti possono creare
            sottodirectory.
          </div>
        </div>
        <div class="card">
          <div class="question">Quali metodi di accesso ai file esistono?</div>
          <div class="answer">
            Sequenziale, diretto, indicizzato (es. ISAM).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un FCB?</div>
          <div class="answer">
            File Control Block: contiene metadati del file, come permessi e
            posizione sul disco.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i principali metodi di allocazione dei file?
          </div>
          <div class="answer">Contigua, legata, indicizzata.</div>
        </div>
      </div>

      <!-- Sezione Reclaiming -->
      <div id="reclaiming" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">Cos'è la strategia di reclaiming pages?</div>
          <div class="answer">
            Una tecnica del kernel che libera memoria quando la free list scende
            sotto una soglia minima, tramite una routine detta "reaper", per
            prevenire il thrashing e mantenere il sistema reattivo.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è NUMA (Non-Uniform Memory Access)?</div>
          <div class="answer">
            È un'architettura in cui l'accesso alla memoria varia in base alla
            CPU: ogni CPU accede più velocemente alla sua memoria locale
            rispetto a quella delle altre CPU.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa causa il thrashing?</div>
          <div class="answer">
            Un numero eccessivo di page fault causati da processi con troppo
            poche pagine disponibili, portando il sistema a passare più tempo a
            gestire pagine che a eseguire codice.
          </div>
        </div>
        <div class="card">
          <div class="question">Come si può prevenire il thrashing?</div>
          <div class="answer">
            Limitando la multiprogrammazione o usando il Locality Model e
            Working Set Model per allocare frame sufficienti ai processi.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa rappresenta il Working Set di un processo?
          </div>
          <div class="answer">
            L'insieme delle pagine usate nelle ultime Δ operazioni di memoria,
            rappresentando una stima della località attiva del processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            In cosa consiste l'algoritmo Page-Fault Frequency (PFF)?
          </div>
          <div class="answer">
            Monitora la frequenza dei page fault: se è alta, aumenta i frame al
            processo; se è bassa, rimuove le pagine non usate.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché la memoria del kernel viene allocata separatamente?
          </div>
          <div class="answer">
            Perché il kernel ha bisogno di allocazioni contigue e oggetti
            piccoli e dinamici, per cui usa sistemi come buddy system e slab
            allocator.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona il buddy system?</div>
          <div class="answer">
            Divide la memoria in blocchi di potenze di due e li suddivide
            ricorsivamente finché trova un blocco adeguato; al rilascio, i buddy
            adiacenti possono essere uniti (coalescing).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la slab allocation?</div>
          <div class="answer">
            È un metodo per allocare oggetti kernel in cache preinizializzate
            (slab), evitando frammentazione e migliorando le performance.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è lo scopo del dirty bit?</div>
          <div class="answer">
            Indica se una pagina è stata modificata: se non lo è, può essere
            rimossa senza salvarla su disco durante un page replacement,
            riducendo overhead.
          </div>
        </div>
      </div>

      <!-- Sezione Processi -->
      <div id="processi" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">
            Cosa sono gli stack utente e kernel in OS161?
          </div>
          <div class="answer">
            Ogni thread ha due stack: uno per l'esecuzione utente, uno per
            l'esecuzione kernel (privilegiata).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa contiene il PCB (Process Control Block)?
          </div>
          <div class="answer">
            Nome, numero thread attivi, spinlock, puntatore a addrspace del
            processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i passaggi per eseguire un programma in OS161?
          </div>
          <div class="answer">
            proc_create_runprogram → thread_fork → runprogram (creazione spazio
            indirizzi, ELF, passaggio al codice utente).
          </div>
        </div>
        <div class="card">
          <div class="question">Come avviene una system call?</div>
          <div class="answer">
            L'utente genera un'interruzione, il kernel esegue la syscall e
            ritorna in user mode.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il demand paging?</div>
          <div class="answer">
            Tecnica che carica in memoria solo le pagine necessarie
            all'esecuzione corrente del processo.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la free-frame list?</div>
          <div class="answer">
            Tiene traccia dei frame liberi da allocare in caso di page fault.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa accade in caso di page fault con frame liberi?
          </div>
          <div class="answer">
            Il frame libero viene assegnato e la pagina viene caricata dal
            disco.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cosa accade in caso di page fault senza frame liberi?
          </div>
          <div class="answer">
            Si sceglie un victim frame da liberare (page replacement), si
            aggiorna la page table e si carica la pagina richiesta.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il copy-on-write?</div>
          <div class="answer">
            Tecnica in cui processi padre e figlio condividono pagine finché non
            vengono modificate.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è la formula dell'EAT?</div>
          <div class="answer">
            EAT = (1 - p) * ma + p * page fault time, con p = probabilità di
            page fault.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è l'algoritmo FIFO di page replacement?
          </div>
          <div class="answer">
            Sostituisce la pagina più vecchia in memoria (prima entrata).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'anomalia di Belady?</div>
          <div class="answer">
            Con FIFO, più frame possono causare più page fault: comportamento
            controintuitivo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Cos'è l'algoritmo Ottimale di page replacement?
          </div>
          <div class="answer">
            Sostituisce la pagina che non sarà usata per il periodo di tempo più
            lungo.
          </div>
        </div>
      </div>

      <!-- Sezione Calcoli -->
      <div id="calcoli" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">
            Quanti bit servono per identificare la pagina con un address space a
            64 bit e pagine da 4KB?
          </div>
          <div class="answer">
            Servono 52 bit per identificare la pagina (64 - 12).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quante voci avrebbe una page table a due livelli per 64-bit?
          </div>
          <div class="answer">
            Primo livello: 2^42 voci; Secondo livello: 2^10 voci. Troppo grande
            da gestire.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come si calcolano le voci in una page table convenzionale?
          </div>
          <div class="answer">
            Numero voci = Virtual address space / Page size.
          </div>
        </div>
        <div class="card">
          <div class="question">
            E come si calcolano le voci in una Inverted Page Table?
          </div>
          <div class="answer">Numero voci = Physical memory / Page size.</div>
        </div>
        <div class="card">
          <div class="question">Qual è la formula dell'EAT con TLB?</div>
          <div class="answer">
            EAT = hit_ratio × TLB_access + miss_ratio × (TLB_access +
            memory_access × livelli_page_table)
          </div>
        </div>
        <div class="card">
          <div class="question">
            Esempio: 21-bit VA, 16-bit PA, 2KB pagine. Quante pagine logiche?
          </div>
          <div class="answer">2^21 / 2^11 = 2^10 = 1024 pagine logiche.</div>
        </div>
        <div class="card">
          <div class="question">
            Esempio: 21-bit VA, 16-bit PA, 2KB pagine. Quante pagine fisiche?
          </div>
          <div class="answer">2^16 / 2^11 = 2^5 = 32 pagine fisiche.</div>
        </div>
        <div class="card">
          <div class="question">
            Esempio: 32-bit VA, 512MB RAM, pagine da 4KB. Quante voci nella page
            table?
          </div>
          <div class="answer">
            Page table convenzionale: 2^20 voci; IPT: 2^17 voci.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il vantaggio dell'IPT?</div>
          <div class="answer">
            Una sola tabella per tutti i processi; riduce l'uso di memoria.
          </div>
        </div>
        <div class="card">
          <div class="question">E lo svantaggio dell'IPT?</div>
          <div class="answer">
            Richiede ricerche lente; migliorabile con hashing o TLB.
          </div>
        </div>
        <div class="card">
          <div class="question">Come funziona una hashed page table?</div>
          <div class="answer">
            Usa una funzione di hash sull'indirizzo virtuale per accedere alla
            tabella; collisioni gestite con liste concatenate.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa accade in uno swap standard?</div>
          <div class="answer">
            L'intero processo viene spostato nel disco (backing store).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il vantaggio dello swapping con paging?
          </div>
          <div class="answer">
            Solo alcune pagine vengono spostate, riducendo il tempo di swap.
          </div>
        </div>
      </div>

      <!-- Sezione Memoria -->
      <div id="memoria" class="section-cards">
        <div class="card">
          <div class="question">Qual è lo scopo del file system?</div>
          <div class="answer">
            Gestire l'archiviazione, l'accesso e la protezione dei file su
            dispositivi secondari.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono alcune strutture del file system?
          </div>
          <div class="answer">
            Directory, attributi, spazio libero, journaling, controlli di
            accesso.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa sono le system call?</div>
          <div class="answer">
            Un'interfaccia per richiedere servizi al kernel.
          </div>
        </div>
        <div class="card">
          <div class="question">Differenza tra mutex e semaforo?</div>
          <div class="answer">
            Il mutex consente accesso esclusivo, il semaforo può controllare
            accesso multiplo con contatore.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene garantita la protezione della memoria?
          </div>
          <div class="answer">
            Tramite i registri base e limit: se l'indirizzo non rientra, si
            genera un trap.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa la MMU?</div>
          <div class="answer">
            Traduce dinamicamente gli indirizzi logici in fisici aggiungendo
            l'indirizzo di rilocazione.
          </div>
        </div>
        <div class="card">
          <div class="question">Differenza tra indirizzo logico e fisico?</div>
          <div class="answer">
            Logico è generato dalla CPU, fisico è usato dalla RAM.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i principali algoritmi di allocazione dinamica?
          </div>
          <div class="answer">First-fit, best-fit, worst-fit.</div>
        </div>
        <div class="card">
          <div class="question">Cos'è la frammentazione interna?</div>
          <div class="answer">
            Parte di memoria allocata ma non utilizzata (es. fine pagina).
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è il paging?</div>
          <div class="answer">
            Tecnica che divide memoria logica in pagine e memoria fisica in
            frame, per evitare frammentazione esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">Vantaggi del paging?</div>
          <div class="answer">
            Elimina frammentazione esterna, supporta esecuzione non contigua.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è l'offset in un indirizzo logico?</div>
          <div class="answer">
            È la posizione interna alla pagina da cui si accede.
          </div>
        </div>
        <div class="card">
          <div class="question">Come lavora la MMU con il paging?</div>
          <div class="answer">
            Estrae la pagina, consulta la page table per il frame, costruisce
            l'indirizzo fisico combinando frame + offset.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Con paging, perché si ha frammentazione interna?
          </div>
          <div class="answer">
            Perché l'ultima pagina può essere solo parzialmente utilizzata.
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il vantaggio principale del paging?</div>
          <div class="answer">
            Permette gestione della memoria non contigua, eliminando la
            frammentazione esterna.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali strutture compongono la memoria nel paging?
          </div>
          <div class="answer">
            Pagine nella memoria logica e frame nella memoria fisica.
          </div>
        </div>
        <div class="card">
          <div class="question">A cosa serve la page table?</div>
          <div class="answer">
            Mappa le pagine logiche ai frame fisici per ciascun processo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come viene diviso un indirizzo logico nel paging?
          </div>
          <div class="answer">
            In Page Number (indice nella page table) e Page Offset (posizione
            nella pagina).
          </div>
        </div>
        <div class="card">
          <div class="question">Qual è il ruolo del PTBR?</div>
          <div class="answer">
            Contiene l'indirizzo base della page table per il processo corrente.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è la TLB?</div>
          <div class="answer">
            Una cache hardware per le traduzioni indirizzi, accelera l'accesso
            alla page table.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa accade in caso di TLB miss?</div>
          <div class="answer">
            Si accede alla page table in memoria, con penalità di tempo.
          </div>
        </div>
        <div class="card">
          <div class="question">Come si proteggono le pagine di memoria?</div>
          <div class="answer">
            Tramite bit di protezione nella page table (es. read-only) e
            valid-invalid bit.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa sono le pagine condivise?</div>
          <div class="answer">
            Pagine di codice condivise da più processi, mentre i dati restano
            separati.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è il problema della page table lineare?
          </div>
          <div class="answer">
            Richiede troppa memoria contigua (es. 4 MB per processo).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la soluzione alla page table lineare?
          </div>
          <div class="answer">
            Usare una page table gerarchica (multi-livello).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Come funziona una page table a due livelli?
          </div>
          <div class="answer">
            L'indirizzo logico è diviso in tre parti: indice esterno, indice
            interno e offset.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la causa della frammentazione interna nel paging?
          </div>
          <div class="answer">
            L'ultima pagina può essere parzialmente inutilizzata.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quanto spazio si spreca mediamente per frammentazione interna?
          </div>
          <div class="answer">In media, mezza pagina per processo.</div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono gli effetti di avere pagine piccole?
          </div>
          <div class="answer">
            Meno frammentazione interna, ma più overhead (più entry nella page
            table).
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono gli effetti di avere pagine grandi?
          </div>
          <div class="answer">
            Più frammentazione interna, ma meno overhead di gestione.
          </div>
        </div>
      </div>

      <!-- Sezione Thread -->
      <div id="thread" class="section-cards" style="display: none">
        <div class="card">
          <div class="question">
            Quali sono gli stati principali di un thread?
          </div>
          <div class="answer">Running, Ready, Blocked/Waiting, Terminated.</div>
        </div>
        <div class="card">
          <div class="question">Cosa contiene il TCB di un thread?</div>
          <div class="answer">
            Stack, PC, registri CPU, stato, e altre info per ripristino.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è un context switch?</div>
          <div class="answer">
            È il salvataggio dello stato del thread attivo e il caricamento di
            quello del thread successivo.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Quali sono i campi chiave di struct thread in OS/161?
          </div>
          <div class="answer">
            t_name, t_state, t_stack, t_context, t_cpu, t_proc, t_wchan_name.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Qual è la relazione tra thread, processo e CPU?
          </div>
          <div class="answer">
            Ogni thread appartiene a un processo; t_cpu indica il core dove è
            attivo.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_fork()?</div>
          <div class="answer">
            Crea un nuovo thread, assegnandogli una funzione iniziale, nome e
            processo.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_yield()?</div>
          <div class="answer">
            Il thread attivo cede volontariamente la CPU.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_exit()?</div>
          <div class="answer">Termina il thread e libera le sue risorse.</div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_consider_migration()?</div>
          <div class="answer">
            Valuta la migrazione del thread su un altro core.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_make_runnable()?</div>
          <div class="answer">
            Inserisce un thread nella coda dei pronti all'esecuzione.
          </div>
        </div>
        <div class="card">
          <div class="question">Cosa fa thread_switch()?</div>
          <div class="answer">
            Gestisce il salvataggio e il caricamento del contesto tra due
            thread.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è switchframe_init()?</div>
          <div class="answer">
            Prepara la struttura dati con lo stato dei registri CPU.
          </div>
        </div>
        <div class="card">
          <div class="question">Cos'è switchframe_switch()?</div>
          <div class="answer">
            Funzione assembly che salva e carica i registri durante il cambio di
            contesto.
          </div>
        </div>
        <div class="card">
          <div class="question">
            Perché OS/161 usa assembly per il context switch?
          </div>
          <div class="answer">
            Perché solo in assembly si possono manipolare direttamente i
            registri della CPU MIPS.
          </div>
        </div>
      </div>
    </div>

    <script>
      // Mostra solo la sezione selezionata
      document.querySelectorAll(".section-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".section-cards").forEach((sec) => {
            sec.style.display = "none";
          });
          document.getElementById(btn.dataset.section).style.display = "block";
        });
      });

      // Gestione apertura card
      function setupCardListeners(sectionId) {
        document.querySelectorAll(`#${sectionId} .card`).forEach((card) => {
          card.addEventListener("click", () => {
            card.classList.toggle("open");
          });
        });
      }

      setupCardListeners("memoria");
      setupCardListeners("thread");
      setupCardListeners("calcoli");
      setupCardListeners("processi");
      setupCardListeners("reclaiming");
      setupCardListeners("os161");
      setupCardListeners("io");
      setupCardListeners("dischi");
    </script>
  </body>
</html>
